// Autogenerated by Thrift Compiler (0.9.1)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package Hbase

import (
	"fmt"
	"git.apache.org/thrift.git/lib/go/thrift"
	"math"
)

// (needed to ensure safety because of naive import list construction.)
var _ = math.MinInt32
var _ = thrift.ZERO
var _ = fmt.Printf

type Hbase interface {
	// Brings a table on-line (enables it)
	//
	// Parameters:
	//  - TableName: name of the table
	EnableTable(tableName Bytes) (io *IOError, err error)
	// Disables a table (takes it off-line) If it is being served, the master
	// will tell the servers to stop serving it.
	//
	// Parameters:
	//  - TableName: name of the table
	DisableTable(tableName Bytes) (io *IOError, err error)
	// @return true if table is on-line
	//
	// Parameters:
	//  - TableName: name of the table to check
	IsTableEnabled(tableName Bytes) (r bool, io *IOError, err error)
	// Parameters:
	//  - TableNameOrRegionName
	Compact(tableNameOrRegionName Bytes) (io *IOError, err error)
	// Parameters:
	//  - TableNameOrRegionName
	MajorCompact(tableNameOrRegionName Bytes) (io *IOError, err error)
	// List all the userspace tables.
	//
	// @return returns a list of names
	GetTableNames() (r []Text, io *IOError, err error)
	// List all the column families assoicated with a table.
	//
	// @return list of column family descriptors
	//
	// Parameters:
	//  - TableName: table name
	GetColumnDescriptors(tableName Text) (r map[Text]*ColumnDescriptor, io *IOError, err error)
	// List the regions associated with a table.
	//
	// @return list of region descriptors
	//
	// Parameters:
	//  - TableName: table name
	GetTableRegions(tableName Text) (r []*TRegionInfo, io *IOError, err error)
	// Create a table with the specified column families.  The name
	// field for each ColumnDescriptor must be set and must end in a
	// colon (:). All other fields are optional and will get default
	// values if not explicitly specified.
	//
	// @throws IllegalArgument if an input parameter is invalid
	//
	// @throws AlreadyExists if the table name already exists
	//
	// Parameters:
	//  - TableName: name of table to create
	//  - ColumnFamilies: list of column family descriptors
	CreateTable(tableName Text, columnFamilies []*ColumnDescriptor) (io *IOError, ia *IllegalArgument, exist *AlreadyExists, err error)
	// Create a table with the specified column families.  The name
	// field for each ColumnDescriptor must be set and must end in a
	// colon (:). All other fields are optional and will get default
	// values if not explicitly specified.
	// Add by lijianbin
	//
	// @throws IllegalArgument if an input parameter is invalid
	//
	// @throws AlreadyExists if the table name already exists
	//
	// Parameters:
	//  - TableName: name of table to create
	//  - SplitKeys: name of table to create
	//  - ColumnFamilies: list of column family descriptors
	MTCreateTable(tableName Text, splitKeys []Text, columnFamilies []*MTColumnDescriptor) (io *IOError, ia *IllegalArgument, exist *AlreadyExists, err error)
	// ADD column family to an exist table.
	// Add by lijianbin
	//
	// @throws IllegalArgument if an input parameter is invalid
	//
	// Parameters:
	//  - TableName: name of table to modify
	//  - ColumnFamilies: list of column family descriptors
	MTAddColumn(tableName Text, columnFamilies []*MTColumnDescriptor) (io *IOError, ia *IllegalArgument, err error)
	// Modify column family of an exist table.
	// Add by lijianbin
	//
	// @throws IllegalArgument if an input parameter is invalid
	//
	// Parameters:
	//  - TableName: name of table to modify
	//  - ColumnFamilies: list of column family descriptors
	MTModifyColumn(tableName Text, columnFamilies []*MTColumnDescriptor) (io *IOError, ia *IllegalArgument, err error)
	// Delete column family from an exist table.
	// Add by lijianbin
	//
	// @throws IllegalArgument if an input parameter is invalid
	//
	// Parameters:
	//  - TableName: name of table to modify
	//  - ColumnNames: name of column family to delete
	MTDeleteColumn(tableName Text, columnNames []string) (io *IOError, ia *IllegalArgument, err error)
	// Deletes a table
	//
	// @throws IOError if table doesn't exist on server or there was some other
	// problem
	//
	// Parameters:
	//  - TableName: name of table to delete
	DeleteTable(tableName Text) (io *IOError, err error)
	// Get a single TCell for the specified table, row, and column at the
	// latest timestamp. Returns an empty list if no such value exists.
	//
	// @return value for specified row/column
	//
	// Parameters:
	//  - TableName: name of table
	//  - Row: row key
	//  - Column: column name
	//  - Attributes: Get attributes
	Get(tableName Text, row Text, column Text, attributes map[Text]Text) (r []*TCell, io *IOError, err error)
	// Get the specified number of versions for the specified table,
	// row, and column.
	//
	// @return list of cells for specified row/column
	//
	// Parameters:
	//  - TableName: name of table
	//  - Row: row key
	//  - Column: column name
	//  - NumVersions: number of versions to retrieve
	//  - Attributes: Get attributes
	GetVer(tableName Text, row Text, column Text, numVersions int32, attributes map[Text]Text) (r []*TCell, io *IOError, err error)
	// Get the specified number of versions for the specified table,
	// row, and column.  Only versions less than or equal to the specified
	// timestamp will be returned.
	//
	// @return list of cells for specified row/column
	//
	// Parameters:
	//  - TableName: name of table
	//  - Row: row key
	//  - Column: column name
	//  - Timestamp: timestamp
	//  - NumVersions: number of versions to retrieve
	//  - Attributes: Get attributes
	GetVerTs(tableName Text, row Text, column Text, timestamp int64, numVersions int32, attributes map[Text]Text) (r []*TCell, io *IOError, err error)
	// Get all the data for the specified table and row at the latest
	// timestamp. Returns an empty list if the row does not exist.
	//
	// @return TRowResult containing the row and map of columns to TCells
	//
	// Parameters:
	//  - TableName: name of table
	//  - Row: row key
	//  - Attributes: Get attributes
	GetRow(tableName Text, row Text, attributes map[Text]Text) (r []*TRowResult, io *IOError, err error)
	// Get the specified columns for the specified table and row at the latest
	// timestamp. Returns an empty list if the row does not exist.
	//
	// @return TRowResult containing the row and map of columns to TCells
	//
	// Parameters:
	//  - TableName: name of table
	//  - Row: row key
	//  - Columns: List of columns to return, null for all columns
	//  - Attributes: Get attributes
	GetRowWithColumns(tableName Text, row Text, columns []Text, attributes map[Text]Text) (r []*TRowResult, io *IOError, err error)
	// Get all the data for the specified table and row at the specified
	// timestamp. Returns an empty list if the row does not exist.
	//
	// @return TRowResult containing the row and map of columns to TCells
	//
	// Parameters:
	//  - TableName: name of the table
	//  - Row: row key
	//  - Timestamp: timestamp
	//  - Attributes: Get attributes
	GetRowTs(tableName Text, row Text, timestamp int64, attributes map[Text]Text) (r []*TRowResult, io *IOError, err error)
	// Get the specified columns for the specified table and row at the specified
	// timestamp. Returns an empty list if the row does not exist.
	//
	// @return TRowResult containing the row and map of columns to TCells
	//
	// Parameters:
	//  - TableName: name of table
	//  - Row: row key
	//  - Columns: List of columns to return, null for all columns
	//  - Timestamp
	//  - Attributes: Get attributes
	GetRowWithColumnsTs(tableName Text, row Text, columns []Text, timestamp int64, attributes map[Text]Text) (r []*TRowResult, io *IOError, err error)
	// Get all the data for the specified table and rows at the latest
	// timestamp. Returns an empty list if no rows exist.
	//
	// @return TRowResult containing the rows and map of columns to TCells
	//
	// Parameters:
	//  - TableName: name of table
	//  - Rows: row keys
	//  - Attributes: Get attributes
	GetRows(tableName Text, rows []Text, attributes map[Text]Text) (r []*TRowResult, io *IOError, err error)
	// Get the specified columns for the specified table and rows at the latest
	// timestamp. Returns an empty list if no rows exist.
	//
	// @return TRowResult containing the rows and map of columns to TCells
	//
	// Parameters:
	//  - TableName: name of table
	//  - Rows: row keys
	//  - Columns: List of columns to return, null for all columns
	//  - Attributes: Get attributes
	GetRowsWithColumns(tableName Text, rows []Text, columns []Text, attributes map[Text]Text) (r []*TRowResult, io *IOError, err error)
	// Get all the data for the specified table and rows at the specified
	// timestamp. Returns an empty list if no rows exist.
	//
	// @return TRowResult containing the rows and map of columns to TCells
	//
	// Parameters:
	//  - TableName: name of the table
	//  - Rows: row keys
	//  - Timestamp: timestamp
	//  - Attributes: Get attributes
	GetRowsTs(tableName Text, rows []Text, timestamp int64, attributes map[Text]Text) (r []*TRowResult, io *IOError, err error)
	// Get the specified columns for the specified table and rows at the specified
	// timestamp. Returns an empty list if no rows exist.
	//
	// @return TRowResult containing the rows and map of columns to TCells
	//
	// Parameters:
	//  - TableName: name of table
	//  - Rows: row keys
	//  - Columns: List of columns to return, null for all columns
	//  - Timestamp
	//  - Attributes: Get attributes
	GetRowsWithColumnsTs(tableName Text, rows []Text, columns []Text, timestamp int64, attributes map[Text]Text) (r []*TRowResult, io *IOError, err error)
	// Apply a series of mutations (updates/deletes) to a row in a
	// single transaction.  If an exception is thrown, then the
	// transaction is aborted.  Default current timestamp is used, and
	// all entries will have an identical timestamp.
	//
	// Parameters:
	//  - TableName: name of table
	//  - Row: row key
	//  - Mutations: list of mutation commands
	//  - Attributes: Mutation attributes
	MutateRow(tableName Text, row Text, mutations []*Mutation, attributes map[Text]Text) (io *IOError, ia *IllegalArgument, err error)
	// Apply a series of mutations (updates/deletes) to a row in a
	// single transaction.  If an exception is thrown, then the
	// transaction is aborted.  The specified timestamp is used, and
	// all entries will have an identical timestamp.
	//
	// Parameters:
	//  - TableName: name of table
	//  - Row: row key
	//  - Mutations: list of mutation commands
	//  - Timestamp: timestamp
	//  - Attributes: Mutation attributes
	MutateRowTs(tableName Text, row Text, mutations []*Mutation, timestamp int64, attributes map[Text]Text) (io *IOError, ia *IllegalArgument, err error)
	// Apply a series of batches (each a series of mutations on a single row)
	// in a single transaction.  If an exception is thrown, then the
	// transaction is aborted.  Default current timestamp is used, and
	// all entries will have an identical timestamp.
	//
	// Parameters:
	//  - TableName: name of table
	//  - RowBatches: list of row batches
	//  - Attributes: Mutation attributes
	MutateRows(tableName Text, rowBatches []*BatchMutation, attributes map[Text]Text) (io *IOError, ia *IllegalArgument, err error)
	// Apply a series of batches (each a series of mutations on a single row)
	// in a single transaction.  If an exception is thrown, then the
	// transaction is aborted.  The specified timestamp is used, and
	// all entries will have an identical timestamp.
	//
	// Parameters:
	//  - TableName: name of table
	//  - RowBatches: list of row batches
	//  - Timestamp: timestamp
	//  - Attributes: Mutation attributes
	MutateRowsTs(tableName Text, rowBatches []*BatchMutation, timestamp int64, attributes map[Text]Text) (io *IOError, ia *IllegalArgument, err error)
	// Atomically increment the column value specified.  Returns the next value post increment.
	//
	// Parameters:
	//  - TableName: name of table
	//  - Row: row to increment
	//  - Column: name of column
	//  - Value: amount to increment by
	AtomicIncrement(tableName Text, row Text, column Text, value int64) (r int64, io *IOError, ia *IllegalArgument, err error)
	// Delete all cells that match the passed row and column.
	//
	// Parameters:
	//  - TableName: name of table
	//  - Row: Row to update
	//  - Column: name of column whose value is to be deleted
	//  - Attributes: Delete attributes
	DeleteAll(tableName Text, row Text, column Text, attributes map[Text]Text) (io *IOError, err error)
	// Delete all cells that match the passed row and column and whose
	// timestamp is equal-to or older than the passed timestamp.
	//
	// Parameters:
	//  - TableName: name of table
	//  - Row: Row to update
	//  - Column: name of column whose value is to be deleted
	//  - Timestamp: timestamp
	//  - Attributes: Delete attributes
	DeleteAllTs(tableName Text, row Text, column Text, timestamp int64, attributes map[Text]Text) (io *IOError, err error)
	// Completely delete the row's cells.
	//
	// Parameters:
	//  - TableName: name of table
	//  - Row: key of the row to be completely deleted.
	//  - Attributes: Delete attributes
	DeleteAllRow(tableName Text, row Text, attributes map[Text]Text) (io *IOError, err error)
	// Increment a cell by the ammount.
	// Increments can be applied async if hbase.regionserver.thrift.coalesceIncrement is set to true.
	// False is the default.  Turn to true if you need the extra performance and can accept some
	// data loss if a thrift server dies with increments still in the queue.
	//
	// Parameters:
	//  - Increment: The single increment to apply
	Increment(increment *TIncrement) (io *IOError, err error)
	// Parameters:
	//  - Increments: The list of increments
	IncrementRows(increments []*TIncrement) (io *IOError, err error)
	// Completely delete the row's cells marked with a timestamp
	// equal-to or older than the passed timestamp.
	//
	// Parameters:
	//  - TableName: name of table
	//  - Row: key of the row to be completely deleted.
	//  - Timestamp: timestamp
	//  - Attributes: Delete attributes
	DeleteAllRowTs(tableName Text, row Text, timestamp int64, attributes map[Text]Text) (io *IOError, err error)
	// Get a scanner on the current table, using the Scan instance
	// for the scan parameters.
	//
	// Parameters:
	//  - TableName: name of table
	//  - Scan: Scan instance
	//  - Attributes: Scan attributes
	ScannerOpenWithScan(tableName Text, scan *TScan, attributes map[Text]Text) (r ScannerID, io *IOError, err error)
	// Get a scanner on the current table starting at the specified row and
	// ending at the last row in the table.  Return the specified columns.
	//
	// @return scanner id to be used with other scanner procedures
	//
	// Parameters:
	//  - TableName: name of table
	//  - StartRow: Starting row in table to scan.
	// Send "" (empty string) to start at the first row.
	//  - Columns: columns to scan. If column name is a column family, all
	// columns of the specified column family are returned. It's also possible
	// to pass a regex in the column qualifier.
	//  - Attributes: Scan attributes
	ScannerOpen(tableName Text, startRow Text, columns []Text, attributes map[Text]Text) (r ScannerID, io *IOError, err error)
	// Get a scanner on the current table starting and stopping at the
	// specified rows.  ending at the last row in the table.  Return the
	// specified columns.
	//
	// @return scanner id to be used with other scanner procedures
	//
	// Parameters:
	//  - TableName: name of table
	//  - StartRow: Starting row in table to scan.
	// Send "" (empty string) to start at the first row.
	//  - StopRow: row to stop scanning on. This row is *not* included in the
	// scanner's results
	//  - Columns: columns to scan. If column name is a column family, all
	// columns of the specified column family are returned. It's also possible
	// to pass a regex in the column qualifier.
	//  - Attributes: Scan attributes
	ScannerOpenWithStop(tableName Text, startRow Text, stopRow Text, columns []Text, attributes map[Text]Text) (r ScannerID, io *IOError, err error)
	// Open a scanner for a given prefix.  That is all rows will have the specified
	// prefix. No other rows will be returned.
	//
	// @return scanner id to use with other scanner calls
	//
	// Parameters:
	//  - TableName: name of table
	//  - StartAndPrefix: the prefix (and thus start row) of the keys you want
	//  - Columns: the columns you want returned
	//  - Attributes: Scan attributes
	ScannerOpenWithPrefix(tableName Text, startAndPrefix Text, columns []Text, attributes map[Text]Text) (r ScannerID, io *IOError, err error)
	// Get a scanner on the current table starting at the specified row and
	// ending at the last row in the table.  Return the specified columns.
	// Only values with the specified timestamp are returned.
	//
	// @return scanner id to be used with other scanner procedures
	//
	// Parameters:
	//  - TableName: name of table
	//  - StartRow: Starting row in table to scan.
	// Send "" (empty string) to start at the first row.
	//  - Columns: columns to scan. If column name is a column family, all
	// columns of the specified column family are returned. It's also possible
	// to pass a regex in the column qualifier.
	//  - Timestamp: timestamp
	//  - Attributes: Scan attributes
	ScannerOpenTs(tableName Text, startRow Text, columns []Text, timestamp int64, attributes map[Text]Text) (r ScannerID, io *IOError, err error)
	// Get a scanner on the current table starting and stopping at the
	// specified rows.  ending at the last row in the table.  Return the
	// specified columns.  Only values with the specified timestamp are
	// returned.
	//
	// @return scanner id to be used with other scanner procedures
	//
	// Parameters:
	//  - TableName: name of table
	//  - StartRow: Starting row in table to scan.
	// Send "" (empty string) to start at the first row.
	//  - StopRow: row to stop scanning on. This row is *not* included in the
	// scanner's results
	//  - Columns: columns to scan. If column name is a column family, all
	// columns of the specified column family are returned. It's also possible
	// to pass a regex in the column qualifier.
	//  - Timestamp: timestamp
	//  - Attributes: Scan attributes
	ScannerOpenWithStopTs(tableName Text, startRow Text, stopRow Text, columns []Text, timestamp int64, attributes map[Text]Text) (r ScannerID, io *IOError, err error)
	// Returns the scanner's current row value and advances to the next
	// row in the table.  When there are no more rows in the table, or a key
	// greater-than-or-equal-to the scanner's specified stopRow is reached,
	// an empty list is returned.
	//
	// @return a TRowResult containing the current row and a map of the columns to TCells.
	//
	// @throws IllegalArgument if ScannerID is invalid
	//
	// @throws NotFound when the scanner reaches the end
	//
	// Parameters:
	//  - Id: id of a scanner returned by scannerOpen
	ScannerGet(id ScannerID) (r []*TRowResult, io *IOError, ia *IllegalArgument, err error)
	// Returns, starting at the scanner's current row value nbRows worth of
	// rows and advances to the next row in the table.  When there are no more
	// rows in the table, or a key greater-than-or-equal-to the scanner's
	// specified stopRow is reached,  an empty list is returned.
	//
	// @return a TRowResult containing the current row and a map of the columns to TCells.
	//
	// @throws IllegalArgument if ScannerID is invalid
	//
	// @throws NotFound when the scanner reaches the end
	//
	// Parameters:
	//  - Id: id of a scanner returned by scannerOpen
	//  - NbRows: number of results to return
	ScannerGetList(id ScannerID, nbRows int32) (r []*TRowResult, io *IOError, ia *IllegalArgument, err error)
	// Closes the server-state associated with an open scanner.
	//
	// @throws IllegalArgument if ScannerID is invalid
	//
	// Parameters:
	//  - Id: id of a scanner returned by scannerOpen
	ScannerClose(id ScannerID) (io *IOError, ia *IllegalArgument, err error)
	// Get the row just before the specified one.
	//
	// @return value for specified row/column
	//
	// Parameters:
	//  - TableName: name of table
	//  - Row: row key
	//  - Family: column name
	GetRowOrBefore(tableName Text, row Text, family Text) (r []*TCell, io *IOError, err error)
	// Get the regininfo for the specified row. It scans
	// the metatable to find region's start and end keys.
	//
	// @return value for specified row/column
	//
	// Parameters:
	//  - Row: row key
	GetRegionInfo(row Text) (r *TRegionInfo, io *IOError, err error)
	// Get the specified num versions of the specified columns for the specified table and row.
	// Returns an empty list if the row does not exist.
	//
	// Add by lijianbin
	//
	// @return TRowResult containing the row and map of columns to TCells
	//
	// Parameters:
	//  - TableName: name of table
	//  - Row: row key
	//  - Columns: List of columns to return, null for all columns
	//  - NumVersions: number of versions to retrieve
	//  - Attributes: Get attributes
	GetRowWithColumnsMaxVer(tableName Text, row Text, columns []Text, numVersions int32, attributes map[Text]Text) (r []*TRowResultWithMultiColVer, io *IOError, err error)
	// Get the specified num versions of  the specified columns for the specified table and
	// row at the specified timestamp. Returns an empty list if the row does not exist.
	//
	// Add by lijianbin
	//
	// @return TRowResult containing the row and map of columns to TCells
	//
	// Parameters:
	//  - TableName: name of table
	//  - Row: row key
	//  - Columns: List of columns to return, null for all columns
	//  - Timestamp
	//  - NumVersions: number of versions to retrieve
	//  - Attributes: Get attributes
	GetRowWithColumnsTsMaxVer(tableName Text, row Text, columns []Text, timestamp int64, numVersions int32, attributes map[Text]Text) (r []*TRowResultWithMultiColVer, io *IOError, err error)
}

type HbaseClient struct {
	Transport       thrift.TTransport
	ProtocolFactory thrift.TProtocolFactory
	InputProtocol   thrift.TProtocol
	OutputProtocol  thrift.TProtocol
	SeqId           int32
}

func NewHbaseClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *HbaseClient {
	return &HbaseClient{Transport: t,
		ProtocolFactory: f,
		InputProtocol:   f.GetProtocol(t),
		OutputProtocol:  f.GetProtocol(t),
		SeqId:           0,
	}
}

func NewHbaseClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *HbaseClient {
	return &HbaseClient{Transport: t,
		ProtocolFactory: nil,
		InputProtocol:   iprot,
		OutputProtocol:  oprot,
		SeqId:           0,
	}
}

// Brings a table on-line (enables it)
//
// Parameters:
//  - TableName: name of the table
func (p *HbaseClient) EnableTable(tableName Bytes) (io *IOError, err error) {
	if err = p.sendEnableTable(tableName); err != nil {
		return
	}
	return p.recvEnableTable()
}

func (p *HbaseClient) sendEnableTable(tableName Bytes) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("enableTable", thrift.CALL, p.SeqId)
	args9 := NewEnableTableArgs()
	args9.TableName = tableName
	err = args9.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *HbaseClient) recvEnableTable() (io *IOError, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error11 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error12 error
		error12, err = error11.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error12
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result10 := NewEnableTableResult()
	err = result10.Read(iprot)
	iprot.ReadMessageEnd()
	if result10.Io != nil {
		io = result10.Io
	}
	return
}

// Disables a table (takes it off-line) If it is being served, the master
// will tell the servers to stop serving it.
//
// Parameters:
//  - TableName: name of the table
func (p *HbaseClient) DisableTable(tableName Bytes) (io *IOError, err error) {
	if err = p.sendDisableTable(tableName); err != nil {
		return
	}
	return p.recvDisableTable()
}

func (p *HbaseClient) sendDisableTable(tableName Bytes) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("disableTable", thrift.CALL, p.SeqId)
	args13 := NewDisableTableArgs()
	args13.TableName = tableName
	err = args13.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *HbaseClient) recvDisableTable() (io *IOError, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error15 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error16 error
		error16, err = error15.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error16
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result14 := NewDisableTableResult()
	err = result14.Read(iprot)
	iprot.ReadMessageEnd()
	if result14.Io != nil {
		io = result14.Io
	}
	return
}

// @return true if table is on-line
//
// Parameters:
//  - TableName: name of the table to check
func (p *HbaseClient) IsTableEnabled(tableName Bytes) (r bool, io *IOError, err error) {
	if err = p.sendIsTableEnabled(tableName); err != nil {
		return
	}
	return p.recvIsTableEnabled()
}

func (p *HbaseClient) sendIsTableEnabled(tableName Bytes) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("isTableEnabled", thrift.CALL, p.SeqId)
	args17 := NewIsTableEnabledArgs()
	args17.TableName = tableName
	err = args17.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *HbaseClient) recvIsTableEnabled() (value bool, io *IOError, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error19 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error20 error
		error20, err = error19.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error20
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result18 := NewIsTableEnabledResult()
	err = result18.Read(iprot)
	iprot.ReadMessageEnd()
	value = result18.Success
	if result18.Io != nil {
		io = result18.Io
	}
	return
}

// Parameters:
//  - TableNameOrRegionName
func (p *HbaseClient) Compact(tableNameOrRegionName Bytes) (io *IOError, err error) {
	if err = p.sendCompact(tableNameOrRegionName); err != nil {
		return
	}
	return p.recvCompact()
}

func (p *HbaseClient) sendCompact(tableNameOrRegionName Bytes) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("compact", thrift.CALL, p.SeqId)
	args21 := NewCompactArgs()
	args21.TableNameOrRegionName = tableNameOrRegionName
	err = args21.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *HbaseClient) recvCompact() (io *IOError, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error23 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error24 error
		error24, err = error23.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error24
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result22 := NewCompactResult()
	err = result22.Read(iprot)
	iprot.ReadMessageEnd()
	if result22.Io != nil {
		io = result22.Io
	}
	return
}

// Parameters:
//  - TableNameOrRegionName
func (p *HbaseClient) MajorCompact(tableNameOrRegionName Bytes) (io *IOError, err error) {
	if err = p.sendMajorCompact(tableNameOrRegionName); err != nil {
		return
	}
	return p.recvMajorCompact()
}

func (p *HbaseClient) sendMajorCompact(tableNameOrRegionName Bytes) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("majorCompact", thrift.CALL, p.SeqId)
	args25 := NewMajorCompactArgs()
	args25.TableNameOrRegionName = tableNameOrRegionName
	err = args25.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *HbaseClient) recvMajorCompact() (io *IOError, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error27 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error28 error
		error28, err = error27.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error28
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result26 := NewMajorCompactResult()
	err = result26.Read(iprot)
	iprot.ReadMessageEnd()
	if result26.Io != nil {
		io = result26.Io
	}
	return
}

// List all the userspace tables.
//
// @return returns a list of names
func (p *HbaseClient) GetTableNames() (r []Text, io *IOError, err error) {
	if err = p.sendGetTableNames(); err != nil {
		return
	}
	return p.recvGetTableNames()
}

func (p *HbaseClient) sendGetTableNames() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("getTableNames", thrift.CALL, p.SeqId)
	args29 := NewGetTableNamesArgs()
	err = args29.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *HbaseClient) recvGetTableNames() (value []Text, io *IOError, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error31 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error32 error
		error32, err = error31.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error32
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result30 := NewGetTableNamesResult()
	err = result30.Read(iprot)
	iprot.ReadMessageEnd()
	value = result30.Success
	if result30.Io != nil {
		io = result30.Io
	}
	return
}

// List all the column families assoicated with a table.
//
// @return list of column family descriptors
//
// Parameters:
//  - TableName: table name
func (p *HbaseClient) GetColumnDescriptors(tableName Text) (r map[Text]*ColumnDescriptor, io *IOError, err error) {
	if err = p.sendGetColumnDescriptors(tableName); err != nil {
		return
	}
	return p.recvGetColumnDescriptors()
}

func (p *HbaseClient) sendGetColumnDescriptors(tableName Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("getColumnDescriptors", thrift.CALL, p.SeqId)
	args33 := NewGetColumnDescriptorsArgs()
	args33.TableName = tableName
	err = args33.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *HbaseClient) recvGetColumnDescriptors() (value map[Text]*ColumnDescriptor, io *IOError, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error35 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error36 error
		error36, err = error35.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error36
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result34 := NewGetColumnDescriptorsResult()
	err = result34.Read(iprot)
	iprot.ReadMessageEnd()
	value = result34.Success
	if result34.Io != nil {
		io = result34.Io
	}
	return
}

// List the regions associated with a table.
//
// @return list of region descriptors
//
// Parameters:
//  - TableName: table name
func (p *HbaseClient) GetTableRegions(tableName Text) (r []*TRegionInfo, io *IOError, err error) {
	if err = p.sendGetTableRegions(tableName); err != nil {
		return
	}
	return p.recvGetTableRegions()
}

func (p *HbaseClient) sendGetTableRegions(tableName Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("getTableRegions", thrift.CALL, p.SeqId)
	args37 := NewGetTableRegionsArgs()
	args37.TableName = tableName
	err = args37.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *HbaseClient) recvGetTableRegions() (value []*TRegionInfo, io *IOError, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error39 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error40 error
		error40, err = error39.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error40
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result38 := NewGetTableRegionsResult()
	err = result38.Read(iprot)
	iprot.ReadMessageEnd()
	value = result38.Success
	if result38.Io != nil {
		io = result38.Io
	}
	return
}

// Create a table with the specified column families.  The name
// field for each ColumnDescriptor must be set and must end in a
// colon (:). All other fields are optional and will get default
// values if not explicitly specified.
//
// @throws IllegalArgument if an input parameter is invalid
//
// @throws AlreadyExists if the table name already exists
//
// Parameters:
//  - TableName: name of table to create
//  - ColumnFamilies: list of column family descriptors
func (p *HbaseClient) CreateTable(tableName Text, columnFamilies []*ColumnDescriptor) (io *IOError, ia *IllegalArgument, exist *AlreadyExists, err error) {
	if err = p.sendCreateTable(tableName, columnFamilies); err != nil {
		return
	}
	return p.recvCreateTable()
}

func (p *HbaseClient) sendCreateTable(tableName Text, columnFamilies []*ColumnDescriptor) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("createTable", thrift.CALL, p.SeqId)
	args41 := NewCreateTableArgs()
	args41.TableName = tableName
	args41.ColumnFamilies = columnFamilies
	err = args41.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *HbaseClient) recvCreateTable() (io *IOError, ia *IllegalArgument, exist *AlreadyExists, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error43 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error44 error
		error44, err = error43.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error44
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result42 := NewCreateTableResult()
	err = result42.Read(iprot)
	iprot.ReadMessageEnd()
	if result42.Io != nil {
		io = result42.Io
	}
	if result42.Ia != nil {
		ia = result42.Ia
	}
	if result42.Exist != nil {
		exist = result42.Exist
	}
	return
}

// Create a table with the specified column families.  The name
// field for each ColumnDescriptor must be set and must end in a
// colon (:). All other fields are optional and will get default
// values if not explicitly specified.
// Add by lijianbin
//
// @throws IllegalArgument if an input parameter is invalid
//
// @throws AlreadyExists if the table name already exists
//
// Parameters:
//  - TableName: name of table to create
//  - SplitKeys: name of table to create
//  - ColumnFamilies: list of column family descriptors
func (p *HbaseClient) MTCreateTable(tableName Text, splitKeys []Text, columnFamilies []*MTColumnDescriptor) (io *IOError, ia *IllegalArgument, exist *AlreadyExists, err error) {
	if err = p.sendMTCreateTable(tableName, splitKeys, columnFamilies); err != nil {
		return
	}
	return p.recvMTCreateTable()
}

func (p *HbaseClient) sendMTCreateTable(tableName Text, splitKeys []Text, columnFamilies []*MTColumnDescriptor) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("MTCreateTable", thrift.CALL, p.SeqId)
	args45 := NewMTCreateTableArgs()
	args45.TableName = tableName
	args45.SplitKeys = splitKeys
	args45.ColumnFamilies = columnFamilies
	err = args45.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *HbaseClient) recvMTCreateTable() (io *IOError, ia *IllegalArgument, exist *AlreadyExists, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error47 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error48 error
		error48, err = error47.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error48
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result46 := NewMTCreateTableResult()
	err = result46.Read(iprot)
	iprot.ReadMessageEnd()
	if result46.Io != nil {
		io = result46.Io
	}
	if result46.Ia != nil {
		ia = result46.Ia
	}
	if result46.Exist != nil {
		exist = result46.Exist
	}
	return
}

// ADD column family to an exist table.
// Add by lijianbin
//
// @throws IllegalArgument if an input parameter is invalid
//
// Parameters:
//  - TableName: name of table to modify
//  - ColumnFamilies: list of column family descriptors
func (p *HbaseClient) MTAddColumn(tableName Text, columnFamilies []*MTColumnDescriptor) (io *IOError, ia *IllegalArgument, err error) {
	if err = p.sendMTAddColumn(tableName, columnFamilies); err != nil {
		return
	}
	return p.recvMTAddColumn()
}

func (p *HbaseClient) sendMTAddColumn(tableName Text, columnFamilies []*MTColumnDescriptor) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("MTAddColumn", thrift.CALL, p.SeqId)
	args49 := NewMTAddColumnArgs()
	args49.TableName = tableName
	args49.ColumnFamilies = columnFamilies
	err = args49.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *HbaseClient) recvMTAddColumn() (io *IOError, ia *IllegalArgument, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error51 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error52 error
		error52, err = error51.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error52
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result50 := NewMTAddColumnResult()
	err = result50.Read(iprot)
	iprot.ReadMessageEnd()
	if result50.Io != nil {
		io = result50.Io
	}
	if result50.Ia != nil {
		ia = result50.Ia
	}
	return
}

// Modify column family of an exist table.
// Add by lijianbin
//
// @throws IllegalArgument if an input parameter is invalid
//
// Parameters:
//  - TableName: name of table to modify
//  - ColumnFamilies: list of column family descriptors
func (p *HbaseClient) MTModifyColumn(tableName Text, columnFamilies []*MTColumnDescriptor) (io *IOError, ia *IllegalArgument, err error) {
	if err = p.sendMTModifyColumn(tableName, columnFamilies); err != nil {
		return
	}
	return p.recvMTModifyColumn()
}

func (p *HbaseClient) sendMTModifyColumn(tableName Text, columnFamilies []*MTColumnDescriptor) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("MTModifyColumn", thrift.CALL, p.SeqId)
	args53 := NewMTModifyColumnArgs()
	args53.TableName = tableName
	args53.ColumnFamilies = columnFamilies
	err = args53.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *HbaseClient) recvMTModifyColumn() (io *IOError, ia *IllegalArgument, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error55 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error56 error
		error56, err = error55.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error56
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result54 := NewMTModifyColumnResult()
	err = result54.Read(iprot)
	iprot.ReadMessageEnd()
	if result54.Io != nil {
		io = result54.Io
	}
	if result54.Ia != nil {
		ia = result54.Ia
	}
	return
}

// Delete column family from an exist table.
// Add by lijianbin
//
// @throws IllegalArgument if an input parameter is invalid
//
// Parameters:
//  - TableName: name of table to modify
//  - ColumnNames: name of column family to delete
func (p *HbaseClient) MTDeleteColumn(tableName Text, columnNames []string) (io *IOError, ia *IllegalArgument, err error) {
	if err = p.sendMTDeleteColumn(tableName, columnNames); err != nil {
		return
	}
	return p.recvMTDeleteColumn()
}

func (p *HbaseClient) sendMTDeleteColumn(tableName Text, columnNames []string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("MTDeleteColumn", thrift.CALL, p.SeqId)
	args57 := NewMTDeleteColumnArgs()
	args57.TableName = tableName
	args57.ColumnNames = columnNames
	err = args57.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *HbaseClient) recvMTDeleteColumn() (io *IOError, ia *IllegalArgument, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error59 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error60 error
		error60, err = error59.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error60
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result58 := NewMTDeleteColumnResult()
	err = result58.Read(iprot)
	iprot.ReadMessageEnd()
	if result58.Io != nil {
		io = result58.Io
	}
	if result58.Ia != nil {
		ia = result58.Ia
	}
	return
}

// Deletes a table
//
// @throws IOError if table doesn't exist on server or there was some other
// problem
//
// Parameters:
//  - TableName: name of table to delete
func (p *HbaseClient) DeleteTable(tableName Text) (io *IOError, err error) {
	if err = p.sendDeleteTable(tableName); err != nil {
		return
	}
	return p.recvDeleteTable()
}

func (p *HbaseClient) sendDeleteTable(tableName Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("deleteTable", thrift.CALL, p.SeqId)
	args61 := NewDeleteTableArgs()
	args61.TableName = tableName
	err = args61.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *HbaseClient) recvDeleteTable() (io *IOError, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error63 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error64 error
		error64, err = error63.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error64
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result62 := NewDeleteTableResult()
	err = result62.Read(iprot)
	iprot.ReadMessageEnd()
	if result62.Io != nil {
		io = result62.Io
	}
	return
}

// Get a single TCell for the specified table, row, and column at the
// latest timestamp. Returns an empty list if no such value exists.
//
// @return value for specified row/column
//
// Parameters:
//  - TableName: name of table
//  - Row: row key
//  - Column: column name
//  - Attributes: Get attributes
func (p *HbaseClient) Get(tableName Text, row Text, column Text, attributes map[Text]Text) (r []*TCell, io *IOError, err error) {
	if err = p.sendGet(tableName, row, column, attributes); err != nil {
		return
	}
	return p.recvGet()
}

func (p *HbaseClient) sendGet(tableName Text, row Text, column Text, attributes map[Text]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("get", thrift.CALL, p.SeqId)
	args65 := NewGetArgs()
	args65.TableName = tableName
	args65.Row = row
	args65.Column = column
	args65.Attributes = attributes
	err = args65.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *HbaseClient) recvGet() (value []*TCell, io *IOError, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error67 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error68 error
		error68, err = error67.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error68
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result66 := NewGetResult()
	err = result66.Read(iprot)
	iprot.ReadMessageEnd()
	value = result66.Success
	if result66.Io != nil {
		io = result66.Io
	}
	return
}

// Get the specified number of versions for the specified table,
// row, and column.
//
// @return list of cells for specified row/column
//
// Parameters:
//  - TableName: name of table
//  - Row: row key
//  - Column: column name
//  - NumVersions: number of versions to retrieve
//  - Attributes: Get attributes
func (p *HbaseClient) GetVer(tableName Text, row Text, column Text, numVersions int32, attributes map[Text]Text) (r []*TCell, io *IOError, err error) {
	if err = p.sendGetVer(tableName, row, column, numVersions, attributes); err != nil {
		return
	}
	return p.recvGetVer()
}

func (p *HbaseClient) sendGetVer(tableName Text, row Text, column Text, numVersions int32, attributes map[Text]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("getVer", thrift.CALL, p.SeqId)
	args69 := NewGetVerArgs()
	args69.TableName = tableName
	args69.Row = row
	args69.Column = column
	args69.NumVersions = numVersions
	args69.Attributes = attributes
	err = args69.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *HbaseClient) recvGetVer() (value []*TCell, io *IOError, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error71 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error72 error
		error72, err = error71.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error72
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result70 := NewGetVerResult()
	err = result70.Read(iprot)
	iprot.ReadMessageEnd()
	value = result70.Success
	if result70.Io != nil {
		io = result70.Io
	}
	return
}

// Get the specified number of versions for the specified table,
// row, and column.  Only versions less than or equal to the specified
// timestamp will be returned.
//
// @return list of cells for specified row/column
//
// Parameters:
//  - TableName: name of table
//  - Row: row key
//  - Column: column name
//  - Timestamp: timestamp
//  - NumVersions: number of versions to retrieve
//  - Attributes: Get attributes
func (p *HbaseClient) GetVerTs(tableName Text, row Text, column Text, timestamp int64, numVersions int32, attributes map[Text]Text) (r []*TCell, io *IOError, err error) {
	if err = p.sendGetVerTs(tableName, row, column, timestamp, numVersions, attributes); err != nil {
		return
	}
	return p.recvGetVerTs()
}

func (p *HbaseClient) sendGetVerTs(tableName Text, row Text, column Text, timestamp int64, numVersions int32, attributes map[Text]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("getVerTs", thrift.CALL, p.SeqId)
	args73 := NewGetVerTsArgs()
	args73.TableName = tableName
	args73.Row = row
	args73.Column = column
	args73.Timestamp = timestamp
	args73.NumVersions = numVersions
	args73.Attributes = attributes
	err = args73.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *HbaseClient) recvGetVerTs() (value []*TCell, io *IOError, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error75 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error76 error
		error76, err = error75.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error76
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result74 := NewGetVerTsResult()
	err = result74.Read(iprot)
	iprot.ReadMessageEnd()
	value = result74.Success
	if result74.Io != nil {
		io = result74.Io
	}
	return
}

// Get all the data for the specified table and row at the latest
// timestamp. Returns an empty list if the row does not exist.
//
// @return TRowResult containing the row and map of columns to TCells
//
// Parameters:
//  - TableName: name of table
//  - Row: row key
//  - Attributes: Get attributes
func (p *HbaseClient) GetRow(tableName Text, row Text, attributes map[Text]Text) (r []*TRowResult, io *IOError, err error) {
	if err = p.sendGetRow(tableName, row, attributes); err != nil {
		return
	}
	return p.recvGetRow()
}

func (p *HbaseClient) sendGetRow(tableName Text, row Text, attributes map[Text]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("getRow", thrift.CALL, p.SeqId)
	args77 := NewGetRowArgs()
	args77.TableName = tableName
	args77.Row = row
	args77.Attributes = attributes
	err = args77.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *HbaseClient) recvGetRow() (value []*TRowResult, io *IOError, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error79 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error80 error
		error80, err = error79.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error80
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result78 := NewGetRowResult()
	err = result78.Read(iprot)
	iprot.ReadMessageEnd()
	value = result78.Success
	if result78.Io != nil {
		io = result78.Io
	}
	return
}

// Get the specified columns for the specified table and row at the latest
// timestamp. Returns an empty list if the row does not exist.
//
// @return TRowResult containing the row and map of columns to TCells
//
// Parameters:
//  - TableName: name of table
//  - Row: row key
//  - Columns: List of columns to return, null for all columns
//  - Attributes: Get attributes
func (p *HbaseClient) GetRowWithColumns(tableName Text, row Text, columns []Text, attributes map[Text]Text) (r []*TRowResult, io *IOError, err error) {
	if err = p.sendGetRowWithColumns(tableName, row, columns, attributes); err != nil {
		return
	}
	return p.recvGetRowWithColumns()
}

func (p *HbaseClient) sendGetRowWithColumns(tableName Text, row Text, columns []Text, attributes map[Text]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("getRowWithColumns", thrift.CALL, p.SeqId)
	args81 := NewGetRowWithColumnsArgs()
	args81.TableName = tableName
	args81.Row = row
	args81.Columns = columns
	args81.Attributes = attributes
	err = args81.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *HbaseClient) recvGetRowWithColumns() (value []*TRowResult, io *IOError, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error83 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error84 error
		error84, err = error83.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error84
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result82 := NewGetRowWithColumnsResult()
	err = result82.Read(iprot)
	iprot.ReadMessageEnd()
	value = result82.Success
	if result82.Io != nil {
		io = result82.Io
	}
	return
}

// Get all the data for the specified table and row at the specified
// timestamp. Returns an empty list if the row does not exist.
//
// @return TRowResult containing the row and map of columns to TCells
//
// Parameters:
//  - TableName: name of the table
//  - Row: row key
//  - Timestamp: timestamp
//  - Attributes: Get attributes
func (p *HbaseClient) GetRowTs(tableName Text, row Text, timestamp int64, attributes map[Text]Text) (r []*TRowResult, io *IOError, err error) {
	if err = p.sendGetRowTs(tableName, row, timestamp, attributes); err != nil {
		return
	}
	return p.recvGetRowTs()
}

func (p *HbaseClient) sendGetRowTs(tableName Text, row Text, timestamp int64, attributes map[Text]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("getRowTs", thrift.CALL, p.SeqId)
	args85 := NewGetRowTsArgs()
	args85.TableName = tableName
	args85.Row = row
	args85.Timestamp = timestamp
	args85.Attributes = attributes
	err = args85.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *HbaseClient) recvGetRowTs() (value []*TRowResult, io *IOError, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error87 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error88 error
		error88, err = error87.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error88
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result86 := NewGetRowTsResult()
	err = result86.Read(iprot)
	iprot.ReadMessageEnd()
	value = result86.Success
	if result86.Io != nil {
		io = result86.Io
	}
	return
}

// Get the specified columns for the specified table and row at the specified
// timestamp. Returns an empty list if the row does not exist.
//
// @return TRowResult containing the row and map of columns to TCells
//
// Parameters:
//  - TableName: name of table
//  - Row: row key
//  - Columns: List of columns to return, null for all columns
//  - Timestamp
//  - Attributes: Get attributes
func (p *HbaseClient) GetRowWithColumnsTs(tableName Text, row Text, columns []Text, timestamp int64, attributes map[Text]Text) (r []*TRowResult, io *IOError, err error) {
	if err = p.sendGetRowWithColumnsTs(tableName, row, columns, timestamp, attributes); err != nil {
		return
	}
	return p.recvGetRowWithColumnsTs()
}

func (p *HbaseClient) sendGetRowWithColumnsTs(tableName Text, row Text, columns []Text, timestamp int64, attributes map[Text]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("getRowWithColumnsTs", thrift.CALL, p.SeqId)
	args89 := NewGetRowWithColumnsTsArgs()
	args89.TableName = tableName
	args89.Row = row
	args89.Columns = columns
	args89.Timestamp = timestamp
	args89.Attributes = attributes
	err = args89.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *HbaseClient) recvGetRowWithColumnsTs() (value []*TRowResult, io *IOError, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error91 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error92 error
		error92, err = error91.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error92
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result90 := NewGetRowWithColumnsTsResult()
	err = result90.Read(iprot)
	iprot.ReadMessageEnd()
	value = result90.Success
	if result90.Io != nil {
		io = result90.Io
	}
	return
}

// Get all the data for the specified table and rows at the latest
// timestamp. Returns an empty list if no rows exist.
//
// @return TRowResult containing the rows and map of columns to TCells
//
// Parameters:
//  - TableName: name of table
//  - Rows: row keys
//  - Attributes: Get attributes
func (p *HbaseClient) GetRows(tableName Text, rows []Text, attributes map[Text]Text) (r []*TRowResult, io *IOError, err error) {
	if err = p.sendGetRows(tableName, rows, attributes); err != nil {
		return
	}
	return p.recvGetRows()
}

func (p *HbaseClient) sendGetRows(tableName Text, rows []Text, attributes map[Text]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("getRows", thrift.CALL, p.SeqId)
	args93 := NewGetRowsArgs()
	args93.TableName = tableName
	args93.Rows = rows
	args93.Attributes = attributes
	err = args93.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *HbaseClient) recvGetRows() (value []*TRowResult, io *IOError, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error95 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error96 error
		error96, err = error95.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error96
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result94 := NewGetRowsResult()
	err = result94.Read(iprot)
	iprot.ReadMessageEnd()
	value = result94.Success
	if result94.Io != nil {
		io = result94.Io
	}
	return
}

// Get the specified columns for the specified table and rows at the latest
// timestamp. Returns an empty list if no rows exist.
//
// @return TRowResult containing the rows and map of columns to TCells
//
// Parameters:
//  - TableName: name of table
//  - Rows: row keys
//  - Columns: List of columns to return, null for all columns
//  - Attributes: Get attributes
func (p *HbaseClient) GetRowsWithColumns(tableName Text, rows []Text, columns []Text, attributes map[Text]Text) (r []*TRowResult, io *IOError, err error) {
	if err = p.sendGetRowsWithColumns(tableName, rows, columns, attributes); err != nil {
		return
	}
	return p.recvGetRowsWithColumns()
}

func (p *HbaseClient) sendGetRowsWithColumns(tableName Text, rows []Text, columns []Text, attributes map[Text]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("getRowsWithColumns", thrift.CALL, p.SeqId)
	args97 := NewGetRowsWithColumnsArgs()
	args97.TableName = tableName
	args97.Rows = rows
	args97.Columns = columns
	args97.Attributes = attributes
	err = args97.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *HbaseClient) recvGetRowsWithColumns() (value []*TRowResult, io *IOError, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error99 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error100 error
		error100, err = error99.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error100
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result98 := NewGetRowsWithColumnsResult()
	err = result98.Read(iprot)
	iprot.ReadMessageEnd()
	value = result98.Success
	if result98.Io != nil {
		io = result98.Io
	}
	return
}

// Get all the data for the specified table and rows at the specified
// timestamp. Returns an empty list if no rows exist.
//
// @return TRowResult containing the rows and map of columns to TCells
//
// Parameters:
//  - TableName: name of the table
//  - Rows: row keys
//  - Timestamp: timestamp
//  - Attributes: Get attributes
func (p *HbaseClient) GetRowsTs(tableName Text, rows []Text, timestamp int64, attributes map[Text]Text) (r []*TRowResult, io *IOError, err error) {
	if err = p.sendGetRowsTs(tableName, rows, timestamp, attributes); err != nil {
		return
	}
	return p.recvGetRowsTs()
}

func (p *HbaseClient) sendGetRowsTs(tableName Text, rows []Text, timestamp int64, attributes map[Text]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("getRowsTs", thrift.CALL, p.SeqId)
	args101 := NewGetRowsTsArgs()
	args101.TableName = tableName
	args101.Rows = rows
	args101.Timestamp = timestamp
	args101.Attributes = attributes
	err = args101.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *HbaseClient) recvGetRowsTs() (value []*TRowResult, io *IOError, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error103 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error104 error
		error104, err = error103.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error104
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result102 := NewGetRowsTsResult()
	err = result102.Read(iprot)
	iprot.ReadMessageEnd()
	value = result102.Success
	if result102.Io != nil {
		io = result102.Io
	}
	return
}

// Get the specified columns for the specified table and rows at the specified
// timestamp. Returns an empty list if no rows exist.
//
// @return TRowResult containing the rows and map of columns to TCells
//
// Parameters:
//  - TableName: name of table
//  - Rows: row keys
//  - Columns: List of columns to return, null for all columns
//  - Timestamp
//  - Attributes: Get attributes
func (p *HbaseClient) GetRowsWithColumnsTs(tableName Text, rows []Text, columns []Text, timestamp int64, attributes map[Text]Text) (r []*TRowResult, io *IOError, err error) {
	if err = p.sendGetRowsWithColumnsTs(tableName, rows, columns, timestamp, attributes); err != nil {
		return
	}
	return p.recvGetRowsWithColumnsTs()
}

func (p *HbaseClient) sendGetRowsWithColumnsTs(tableName Text, rows []Text, columns []Text, timestamp int64, attributes map[Text]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("getRowsWithColumnsTs", thrift.CALL, p.SeqId)
	args105 := NewGetRowsWithColumnsTsArgs()
	args105.TableName = tableName
	args105.Rows = rows
	args105.Columns = columns
	args105.Timestamp = timestamp
	args105.Attributes = attributes
	err = args105.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *HbaseClient) recvGetRowsWithColumnsTs() (value []*TRowResult, io *IOError, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error107 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error108 error
		error108, err = error107.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error108
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result106 := NewGetRowsWithColumnsTsResult()
	err = result106.Read(iprot)
	iprot.ReadMessageEnd()
	value = result106.Success
	if result106.Io != nil {
		io = result106.Io
	}
	return
}

// Apply a series of mutations (updates/deletes) to a row in a
// single transaction.  If an exception is thrown, then the
// transaction is aborted.  Default current timestamp is used, and
// all entries will have an identical timestamp.
//
// Parameters:
//  - TableName: name of table
//  - Row: row key
//  - Mutations: list of mutation commands
//  - Attributes: Mutation attributes
func (p *HbaseClient) MutateRow(tableName Text, row Text, mutations []*Mutation, attributes map[Text]Text) (io *IOError, ia *IllegalArgument, err error) {
	if err = p.sendMutateRow(tableName, row, mutations, attributes); err != nil {
		return
	}
	return p.recvMutateRow()
}

func (p *HbaseClient) sendMutateRow(tableName Text, row Text, mutations []*Mutation, attributes map[Text]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("mutateRow", thrift.CALL, p.SeqId)
	args109 := NewMutateRowArgs()
	args109.TableName = tableName
	args109.Row = row
	args109.Mutations = mutations
	args109.Attributes = attributes
	err = args109.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *HbaseClient) recvMutateRow() (io *IOError, ia *IllegalArgument, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error111 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error112 error
		error112, err = error111.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error112
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result110 := NewMutateRowResult()
	err = result110.Read(iprot)
	iprot.ReadMessageEnd()
	if result110.Io != nil {
		io = result110.Io
	}
	if result110.Ia != nil {
		ia = result110.Ia
	}
	return
}

// Apply a series of mutations (updates/deletes) to a row in a
// single transaction.  If an exception is thrown, then the
// transaction is aborted.  The specified timestamp is used, and
// all entries will have an identical timestamp.
//
// Parameters:
//  - TableName: name of table
//  - Row: row key
//  - Mutations: list of mutation commands
//  - Timestamp: timestamp
//  - Attributes: Mutation attributes
func (p *HbaseClient) MutateRowTs(tableName Text, row Text, mutations []*Mutation, timestamp int64, attributes map[Text]Text) (io *IOError, ia *IllegalArgument, err error) {
	if err = p.sendMutateRowTs(tableName, row, mutations, timestamp, attributes); err != nil {
		return
	}
	return p.recvMutateRowTs()
}

func (p *HbaseClient) sendMutateRowTs(tableName Text, row Text, mutations []*Mutation, timestamp int64, attributes map[Text]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("mutateRowTs", thrift.CALL, p.SeqId)
	args113 := NewMutateRowTsArgs()
	args113.TableName = tableName
	args113.Row = row
	args113.Mutations = mutations
	args113.Timestamp = timestamp
	args113.Attributes = attributes
	err = args113.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *HbaseClient) recvMutateRowTs() (io *IOError, ia *IllegalArgument, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error115 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error116 error
		error116, err = error115.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error116
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result114 := NewMutateRowTsResult()
	err = result114.Read(iprot)
	iprot.ReadMessageEnd()
	if result114.Io != nil {
		io = result114.Io
	}
	if result114.Ia != nil {
		ia = result114.Ia
	}
	return
}

// Apply a series of batches (each a series of mutations on a single row)
// in a single transaction.  If an exception is thrown, then the
// transaction is aborted.  Default current timestamp is used, and
// all entries will have an identical timestamp.
//
// Parameters:
//  - TableName: name of table
//  - RowBatches: list of row batches
//  - Attributes: Mutation attributes
func (p *HbaseClient) MutateRows(tableName Text, rowBatches []*BatchMutation, attributes map[Text]Text) (io *IOError, ia *IllegalArgument, err error) {
	if err = p.sendMutateRows(tableName, rowBatches, attributes); err != nil {
		return
	}
	return p.recvMutateRows()
}

func (p *HbaseClient) sendMutateRows(tableName Text, rowBatches []*BatchMutation, attributes map[Text]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("mutateRows", thrift.CALL, p.SeqId)
	args117 := NewMutateRowsArgs()
	args117.TableName = tableName
	args117.RowBatches = rowBatches
	args117.Attributes = attributes
	err = args117.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *HbaseClient) recvMutateRows() (io *IOError, ia *IllegalArgument, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error119 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error120 error
		error120, err = error119.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error120
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result118 := NewMutateRowsResult()
	err = result118.Read(iprot)
	iprot.ReadMessageEnd()
	if result118.Io != nil {
		io = result118.Io
	}
	if result118.Ia != nil {
		ia = result118.Ia
	}
	return
}

// Apply a series of batches (each a series of mutations on a single row)
// in a single transaction.  If an exception is thrown, then the
// transaction is aborted.  The specified timestamp is used, and
// all entries will have an identical timestamp.
//
// Parameters:
//  - TableName: name of table
//  - RowBatches: list of row batches
//  - Timestamp: timestamp
//  - Attributes: Mutation attributes
func (p *HbaseClient) MutateRowsTs(tableName Text, rowBatches []*BatchMutation, timestamp int64, attributes map[Text]Text) (io *IOError, ia *IllegalArgument, err error) {
	if err = p.sendMutateRowsTs(tableName, rowBatches, timestamp, attributes); err != nil {
		return
	}
	return p.recvMutateRowsTs()
}

func (p *HbaseClient) sendMutateRowsTs(tableName Text, rowBatches []*BatchMutation, timestamp int64, attributes map[Text]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("mutateRowsTs", thrift.CALL, p.SeqId)
	args121 := NewMutateRowsTsArgs()
	args121.TableName = tableName
	args121.RowBatches = rowBatches
	args121.Timestamp = timestamp
	args121.Attributes = attributes
	err = args121.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *HbaseClient) recvMutateRowsTs() (io *IOError, ia *IllegalArgument, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error123 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error124 error
		error124, err = error123.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error124
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result122 := NewMutateRowsTsResult()
	err = result122.Read(iprot)
	iprot.ReadMessageEnd()
	if result122.Io != nil {
		io = result122.Io
	}
	if result122.Ia != nil {
		ia = result122.Ia
	}
	return
}

// Atomically increment the column value specified.  Returns the next value post increment.
//
// Parameters:
//  - TableName: name of table
//  - Row: row to increment
//  - Column: name of column
//  - Value: amount to increment by
func (p *HbaseClient) AtomicIncrement(tableName Text, row Text, column Text, value int64) (r int64, io *IOError, ia *IllegalArgument, err error) {
	if err = p.sendAtomicIncrement(tableName, row, column, value); err != nil {
		return
	}
	return p.recvAtomicIncrement()
}

func (p *HbaseClient) sendAtomicIncrement(tableName Text, row Text, column Text, value int64) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("atomicIncrement", thrift.CALL, p.SeqId)
	args125 := NewAtomicIncrementArgs()
	args125.TableName = tableName
	args125.Row = row
	args125.Column = column
	args125.Value = value
	err = args125.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *HbaseClient) recvAtomicIncrement() (value int64, io *IOError, ia *IllegalArgument, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error127 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error128 error
		error128, err = error127.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error128
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result126 := NewAtomicIncrementResult()
	err = result126.Read(iprot)
	iprot.ReadMessageEnd()
	value = result126.Success
	if result126.Io != nil {
		io = result126.Io
	}
	if result126.Ia != nil {
		ia = result126.Ia
	}
	return
}

// Delete all cells that match the passed row and column.
//
// Parameters:
//  - TableName: name of table
//  - Row: Row to update
//  - Column: name of column whose value is to be deleted
//  - Attributes: Delete attributes
func (p *HbaseClient) DeleteAll(tableName Text, row Text, column Text, attributes map[Text]Text) (io *IOError, err error) {
	if err = p.sendDeleteAll(tableName, row, column, attributes); err != nil {
		return
	}
	return p.recvDeleteAll()
}

func (p *HbaseClient) sendDeleteAll(tableName Text, row Text, column Text, attributes map[Text]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("deleteAll", thrift.CALL, p.SeqId)
	args129 := NewDeleteAllArgs()
	args129.TableName = tableName
	args129.Row = row
	args129.Column = column
	args129.Attributes = attributes
	err = args129.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *HbaseClient) recvDeleteAll() (io *IOError, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error131 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error132 error
		error132, err = error131.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error132
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result130 := NewDeleteAllResult()
	err = result130.Read(iprot)
	iprot.ReadMessageEnd()
	if result130.Io != nil {
		io = result130.Io
	}
	return
}

// Delete all cells that match the passed row and column and whose
// timestamp is equal-to or older than the passed timestamp.
//
// Parameters:
//  - TableName: name of table
//  - Row: Row to update
//  - Column: name of column whose value is to be deleted
//  - Timestamp: timestamp
//  - Attributes: Delete attributes
func (p *HbaseClient) DeleteAllTs(tableName Text, row Text, column Text, timestamp int64, attributes map[Text]Text) (io *IOError, err error) {
	if err = p.sendDeleteAllTs(tableName, row, column, timestamp, attributes); err != nil {
		return
	}
	return p.recvDeleteAllTs()
}

func (p *HbaseClient) sendDeleteAllTs(tableName Text, row Text, column Text, timestamp int64, attributes map[Text]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("deleteAllTs", thrift.CALL, p.SeqId)
	args133 := NewDeleteAllTsArgs()
	args133.TableName = tableName
	args133.Row = row
	args133.Column = column
	args133.Timestamp = timestamp
	args133.Attributes = attributes
	err = args133.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *HbaseClient) recvDeleteAllTs() (io *IOError, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error135 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error136 error
		error136, err = error135.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error136
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result134 := NewDeleteAllTsResult()
	err = result134.Read(iprot)
	iprot.ReadMessageEnd()
	if result134.Io != nil {
		io = result134.Io
	}
	return
}

// Completely delete the row's cells.
//
// Parameters:
//  - TableName: name of table
//  - Row: key of the row to be completely deleted.
//  - Attributes: Delete attributes
func (p *HbaseClient) DeleteAllRow(tableName Text, row Text, attributes map[Text]Text) (io *IOError, err error) {
	if err = p.sendDeleteAllRow(tableName, row, attributes); err != nil {
		return
	}
	return p.recvDeleteAllRow()
}

func (p *HbaseClient) sendDeleteAllRow(tableName Text, row Text, attributes map[Text]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("deleteAllRow", thrift.CALL, p.SeqId)
	args137 := NewDeleteAllRowArgs()
	args137.TableName = tableName
	args137.Row = row
	args137.Attributes = attributes
	err = args137.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *HbaseClient) recvDeleteAllRow() (io *IOError, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error139 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error140 error
		error140, err = error139.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error140
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result138 := NewDeleteAllRowResult()
	err = result138.Read(iprot)
	iprot.ReadMessageEnd()
	if result138.Io != nil {
		io = result138.Io
	}
	return
}

// Increment a cell by the ammount.
// Increments can be applied async if hbase.regionserver.thrift.coalesceIncrement is set to true.
// False is the default.  Turn to true if you need the extra performance and can accept some
// data loss if a thrift server dies with increments still in the queue.
//
// Parameters:
//  - Increment: The single increment to apply
func (p *HbaseClient) Increment(increment *TIncrement) (io *IOError, err error) {
	if err = p.sendIncrement(increment); err != nil {
		return
	}
	return p.recvIncrement()
}

func (p *HbaseClient) sendIncrement(increment *TIncrement) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("increment", thrift.CALL, p.SeqId)
	args141 := NewIncrementArgs()
	args141.Increment = increment
	err = args141.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *HbaseClient) recvIncrement() (io *IOError, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error143 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error144 error
		error144, err = error143.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error144
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result142 := NewIncrementResult()
	err = result142.Read(iprot)
	iprot.ReadMessageEnd()
	if result142.Io != nil {
		io = result142.Io
	}
	return
}

// Parameters:
//  - Increments: The list of increments
func (p *HbaseClient) IncrementRows(increments []*TIncrement) (io *IOError, err error) {
	if err = p.sendIncrementRows(increments); err != nil {
		return
	}
	return p.recvIncrementRows()
}

func (p *HbaseClient) sendIncrementRows(increments []*TIncrement) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("incrementRows", thrift.CALL, p.SeqId)
	args145 := NewIncrementRowsArgs()
	args145.Increments = increments
	err = args145.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *HbaseClient) recvIncrementRows() (io *IOError, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error147 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error148 error
		error148, err = error147.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error148
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result146 := NewIncrementRowsResult()
	err = result146.Read(iprot)
	iprot.ReadMessageEnd()
	if result146.Io != nil {
		io = result146.Io
	}
	return
}

// Completely delete the row's cells marked with a timestamp
// equal-to or older than the passed timestamp.
//
// Parameters:
//  - TableName: name of table
//  - Row: key of the row to be completely deleted.
//  - Timestamp: timestamp
//  - Attributes: Delete attributes
func (p *HbaseClient) DeleteAllRowTs(tableName Text, row Text, timestamp int64, attributes map[Text]Text) (io *IOError, err error) {
	if err = p.sendDeleteAllRowTs(tableName, row, timestamp, attributes); err != nil {
		return
	}
	return p.recvDeleteAllRowTs()
}

func (p *HbaseClient) sendDeleteAllRowTs(tableName Text, row Text, timestamp int64, attributes map[Text]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("deleteAllRowTs", thrift.CALL, p.SeqId)
	args149 := NewDeleteAllRowTsArgs()
	args149.TableName = tableName
	args149.Row = row
	args149.Timestamp = timestamp
	args149.Attributes = attributes
	err = args149.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *HbaseClient) recvDeleteAllRowTs() (io *IOError, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error151 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error152 error
		error152, err = error151.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error152
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result150 := NewDeleteAllRowTsResult()
	err = result150.Read(iprot)
	iprot.ReadMessageEnd()
	if result150.Io != nil {
		io = result150.Io
	}
	return
}

// Get a scanner on the current table, using the Scan instance
// for the scan parameters.
//
// Parameters:
//  - TableName: name of table
//  - Scan: Scan instance
//  - Attributes: Scan attributes
func (p *HbaseClient) ScannerOpenWithScan(tableName Text, scan *TScan, attributes map[Text]Text) (r ScannerID, io *IOError, err error) {
	if err = p.sendScannerOpenWithScan(tableName, scan, attributes); err != nil {
		return
	}
	return p.recvScannerOpenWithScan()
}

func (p *HbaseClient) sendScannerOpenWithScan(tableName Text, scan *TScan, attributes map[Text]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("scannerOpenWithScan", thrift.CALL, p.SeqId)
	args153 := NewScannerOpenWithScanArgs()
	args153.TableName = tableName
	args153.Scan = scan
	args153.Attributes = attributes
	err = args153.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *HbaseClient) recvScannerOpenWithScan() (value ScannerID, io *IOError, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error155 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error156 error
		error156, err = error155.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error156
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result154 := NewScannerOpenWithScanResult()
	err = result154.Read(iprot)
	iprot.ReadMessageEnd()
	value = result154.Success
	if result154.Io != nil {
		io = result154.Io
	}
	return
}

// Get a scanner on the current table starting at the specified row and
// ending at the last row in the table.  Return the specified columns.
//
// @return scanner id to be used with other scanner procedures
//
// Parameters:
//  - TableName: name of table
//  - StartRow: Starting row in table to scan.
// Send "" (empty string) to start at the first row.
//  - Columns: columns to scan. If column name is a column family, all
// columns of the specified column family are returned. It's also possible
// to pass a regex in the column qualifier.
//  - Attributes: Scan attributes
func (p *HbaseClient) ScannerOpen(tableName Text, startRow Text, columns []Text, attributes map[Text]Text) (r ScannerID, io *IOError, err error) {
	if err = p.sendScannerOpen(tableName, startRow, columns, attributes); err != nil {
		return
	}
	return p.recvScannerOpen()
}

func (p *HbaseClient) sendScannerOpen(tableName Text, startRow Text, columns []Text, attributes map[Text]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("scannerOpen", thrift.CALL, p.SeqId)
	args157 := NewScannerOpenArgs()
	args157.TableName = tableName
	args157.StartRow = startRow
	args157.Columns = columns
	args157.Attributes = attributes
	err = args157.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *HbaseClient) recvScannerOpen() (value ScannerID, io *IOError, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error159 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error160 error
		error160, err = error159.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error160
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result158 := NewScannerOpenResult()
	err = result158.Read(iprot)
	iprot.ReadMessageEnd()
	value = result158.Success
	if result158.Io != nil {
		io = result158.Io
	}
	return
}

// Get a scanner on the current table starting and stopping at the
// specified rows.  ending at the last row in the table.  Return the
// specified columns.
//
// @return scanner id to be used with other scanner procedures
//
// Parameters:
//  - TableName: name of table
//  - StartRow: Starting row in table to scan.
// Send "" (empty string) to start at the first row.
//  - StopRow: row to stop scanning on. This row is *not* included in the
// scanner's results
//  - Columns: columns to scan. If column name is a column family, all
// columns of the specified column family are returned. It's also possible
// to pass a regex in the column qualifier.
//  - Attributes: Scan attributes
func (p *HbaseClient) ScannerOpenWithStop(tableName Text, startRow Text, stopRow Text, columns []Text, attributes map[Text]Text) (r ScannerID, io *IOError, err error) {
	if err = p.sendScannerOpenWithStop(tableName, startRow, stopRow, columns, attributes); err != nil {
		return
	}
	return p.recvScannerOpenWithStop()
}

func (p *HbaseClient) sendScannerOpenWithStop(tableName Text, startRow Text, stopRow Text, columns []Text, attributes map[Text]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("scannerOpenWithStop", thrift.CALL, p.SeqId)
	args161 := NewScannerOpenWithStopArgs()
	args161.TableName = tableName
	args161.StartRow = startRow
	args161.StopRow = stopRow
	args161.Columns = columns
	args161.Attributes = attributes
	err = args161.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *HbaseClient) recvScannerOpenWithStop() (value ScannerID, io *IOError, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error163 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error164 error
		error164, err = error163.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error164
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result162 := NewScannerOpenWithStopResult()
	err = result162.Read(iprot)
	iprot.ReadMessageEnd()
	value = result162.Success
	if result162.Io != nil {
		io = result162.Io
	}
	return
}

// Open a scanner for a given prefix.  That is all rows will have the specified
// prefix. No other rows will be returned.
//
// @return scanner id to use with other scanner calls
//
// Parameters:
//  - TableName: name of table
//  - StartAndPrefix: the prefix (and thus start row) of the keys you want
//  - Columns: the columns you want returned
//  - Attributes: Scan attributes
func (p *HbaseClient) ScannerOpenWithPrefix(tableName Text, startAndPrefix Text, columns []Text, attributes map[Text]Text) (r ScannerID, io *IOError, err error) {
	if err = p.sendScannerOpenWithPrefix(tableName, startAndPrefix, columns, attributes); err != nil {
		return
	}
	return p.recvScannerOpenWithPrefix()
}

func (p *HbaseClient) sendScannerOpenWithPrefix(tableName Text, startAndPrefix Text, columns []Text, attributes map[Text]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("scannerOpenWithPrefix", thrift.CALL, p.SeqId)
	args165 := NewScannerOpenWithPrefixArgs()
	args165.TableName = tableName
	args165.StartAndPrefix = startAndPrefix
	args165.Columns = columns
	args165.Attributes = attributes
	err = args165.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *HbaseClient) recvScannerOpenWithPrefix() (value ScannerID, io *IOError, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error167 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error168 error
		error168, err = error167.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error168
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result166 := NewScannerOpenWithPrefixResult()
	err = result166.Read(iprot)
	iprot.ReadMessageEnd()
	value = result166.Success
	if result166.Io != nil {
		io = result166.Io
	}
	return
}

// Get a scanner on the current table starting at the specified row and
// ending at the last row in the table.  Return the specified columns.
// Only values with the specified timestamp are returned.
//
// @return scanner id to be used with other scanner procedures
//
// Parameters:
//  - TableName: name of table
//  - StartRow: Starting row in table to scan.
// Send "" (empty string) to start at the first row.
//  - Columns: columns to scan. If column name is a column family, all
// columns of the specified column family are returned. It's also possible
// to pass a regex in the column qualifier.
//  - Timestamp: timestamp
//  - Attributes: Scan attributes
func (p *HbaseClient) ScannerOpenTs(tableName Text, startRow Text, columns []Text, timestamp int64, attributes map[Text]Text) (r ScannerID, io *IOError, err error) {
	if err = p.sendScannerOpenTs(tableName, startRow, columns, timestamp, attributes); err != nil {
		return
	}
	return p.recvScannerOpenTs()
}

func (p *HbaseClient) sendScannerOpenTs(tableName Text, startRow Text, columns []Text, timestamp int64, attributes map[Text]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("scannerOpenTs", thrift.CALL, p.SeqId)
	args169 := NewScannerOpenTsArgs()
	args169.TableName = tableName
	args169.StartRow = startRow
	args169.Columns = columns
	args169.Timestamp = timestamp
	args169.Attributes = attributes
	err = args169.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *HbaseClient) recvScannerOpenTs() (value ScannerID, io *IOError, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error171 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error172 error
		error172, err = error171.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error172
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result170 := NewScannerOpenTsResult()
	err = result170.Read(iprot)
	iprot.ReadMessageEnd()
	value = result170.Success
	if result170.Io != nil {
		io = result170.Io
	}
	return
}

// Get a scanner on the current table starting and stopping at the
// specified rows.  ending at the last row in the table.  Return the
// specified columns.  Only values with the specified timestamp are
// returned.
//
// @return scanner id to be used with other scanner procedures
//
// Parameters:
//  - TableName: name of table
//  - StartRow: Starting row in table to scan.
// Send "" (empty string) to start at the first row.
//  - StopRow: row to stop scanning on. This row is *not* included in the
// scanner's results
//  - Columns: columns to scan. If column name is a column family, all
// columns of the specified column family are returned. It's also possible
// to pass a regex in the column qualifier.
//  - Timestamp: timestamp
//  - Attributes: Scan attributes
func (p *HbaseClient) ScannerOpenWithStopTs(tableName Text, startRow Text, stopRow Text, columns []Text, timestamp int64, attributes map[Text]Text) (r ScannerID, io *IOError, err error) {
	if err = p.sendScannerOpenWithStopTs(tableName, startRow, stopRow, columns, timestamp, attributes); err != nil {
		return
	}
	return p.recvScannerOpenWithStopTs()
}

func (p *HbaseClient) sendScannerOpenWithStopTs(tableName Text, startRow Text, stopRow Text, columns []Text, timestamp int64, attributes map[Text]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("scannerOpenWithStopTs", thrift.CALL, p.SeqId)
	args173 := NewScannerOpenWithStopTsArgs()
	args173.TableName = tableName
	args173.StartRow = startRow
	args173.StopRow = stopRow
	args173.Columns = columns
	args173.Timestamp = timestamp
	args173.Attributes = attributes
	err = args173.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *HbaseClient) recvScannerOpenWithStopTs() (value ScannerID, io *IOError, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error175 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error176 error
		error176, err = error175.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error176
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result174 := NewScannerOpenWithStopTsResult()
	err = result174.Read(iprot)
	iprot.ReadMessageEnd()
	value = result174.Success
	if result174.Io != nil {
		io = result174.Io
	}
	return
}

// Returns the scanner's current row value and advances to the next
// row in the table.  When there are no more rows in the table, or a key
// greater-than-or-equal-to the scanner's specified stopRow is reached,
// an empty list is returned.
//
// @return a TRowResult containing the current row and a map of the columns to TCells.
//
// @throws IllegalArgument if ScannerID is invalid
//
// @throws NotFound when the scanner reaches the end
//
// Parameters:
//  - Id: id of a scanner returned by scannerOpen
func (p *HbaseClient) ScannerGet(id ScannerID) (r []*TRowResult, io *IOError, ia *IllegalArgument, err error) {
	if err = p.sendScannerGet(id); err != nil {
		return
	}
	return p.recvScannerGet()
}

func (p *HbaseClient) sendScannerGet(id ScannerID) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("scannerGet", thrift.CALL, p.SeqId)
	args177 := NewScannerGetArgs()
	args177.Id = id
	err = args177.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *HbaseClient) recvScannerGet() (value []*TRowResult, io *IOError, ia *IllegalArgument, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error179 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error180 error
		error180, err = error179.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error180
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result178 := NewScannerGetResult()
	err = result178.Read(iprot)
	iprot.ReadMessageEnd()
	value = result178.Success
	if result178.Io != nil {
		io = result178.Io
	}
	if result178.Ia != nil {
		ia = result178.Ia
	}
	return
}

// Returns, starting at the scanner's current row value nbRows worth of
// rows and advances to the next row in the table.  When there are no more
// rows in the table, or a key greater-than-or-equal-to the scanner's
// specified stopRow is reached,  an empty list is returned.
//
// @return a TRowResult containing the current row and a map of the columns to TCells.
//
// @throws IllegalArgument if ScannerID is invalid
//
// @throws NotFound when the scanner reaches the end
//
// Parameters:
//  - Id: id of a scanner returned by scannerOpen
//  - NbRows: number of results to return
func (p *HbaseClient) ScannerGetList(id ScannerID, nbRows int32) (r []*TRowResult, io *IOError, ia *IllegalArgument, err error) {
	if err = p.sendScannerGetList(id, nbRows); err != nil {
		return
	}
	return p.recvScannerGetList()
}

func (p *HbaseClient) sendScannerGetList(id ScannerID, nbRows int32) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("scannerGetList", thrift.CALL, p.SeqId)
	args181 := NewScannerGetListArgs()
	args181.Id = id
	args181.NbRows = nbRows
	err = args181.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *HbaseClient) recvScannerGetList() (value []*TRowResult, io *IOError, ia *IllegalArgument, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error183 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error184 error
		error184, err = error183.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error184
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result182 := NewScannerGetListResult()
	err = result182.Read(iprot)
	iprot.ReadMessageEnd()
	value = result182.Success
	if result182.Io != nil {
		io = result182.Io
	}
	if result182.Ia != nil {
		ia = result182.Ia
	}
	return
}

// Closes the server-state associated with an open scanner.
//
// @throws IllegalArgument if ScannerID is invalid
//
// Parameters:
//  - Id: id of a scanner returned by scannerOpen
func (p *HbaseClient) ScannerClose(id ScannerID) (io *IOError, ia *IllegalArgument, err error) {
	if err = p.sendScannerClose(id); err != nil {
		return
	}
	return p.recvScannerClose()
}

func (p *HbaseClient) sendScannerClose(id ScannerID) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("scannerClose", thrift.CALL, p.SeqId)
	args185 := NewScannerCloseArgs()
	args185.Id = id
	err = args185.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *HbaseClient) recvScannerClose() (io *IOError, ia *IllegalArgument, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error187 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error188 error
		error188, err = error187.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error188
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result186 := NewScannerCloseResult()
	err = result186.Read(iprot)
	iprot.ReadMessageEnd()
	if result186.Io != nil {
		io = result186.Io
	}
	if result186.Ia != nil {
		ia = result186.Ia
	}
	return
}

// Get the row just before the specified one.
//
// @return value for specified row/column
//
// Parameters:
//  - TableName: name of table
//  - Row: row key
//  - Family: column name
func (p *HbaseClient) GetRowOrBefore(tableName Text, row Text, family Text) (r []*TCell, io *IOError, err error) {
	if err = p.sendGetRowOrBefore(tableName, row, family); err != nil {
		return
	}
	return p.recvGetRowOrBefore()
}

func (p *HbaseClient) sendGetRowOrBefore(tableName Text, row Text, family Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("getRowOrBefore", thrift.CALL, p.SeqId)
	args189 := NewGetRowOrBeforeArgs()
	args189.TableName = tableName
	args189.Row = row
	args189.Family = family
	err = args189.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *HbaseClient) recvGetRowOrBefore() (value []*TCell, io *IOError, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error191 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error192 error
		error192, err = error191.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error192
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result190 := NewGetRowOrBeforeResult()
	err = result190.Read(iprot)
	iprot.ReadMessageEnd()
	value = result190.Success
	if result190.Io != nil {
		io = result190.Io
	}
	return
}

// Get the regininfo for the specified row. It scans
// the metatable to find region's start and end keys.
//
// @return value for specified row/column
//
// Parameters:
//  - Row: row key
func (p *HbaseClient) GetRegionInfo(row Text) (r *TRegionInfo, io *IOError, err error) {
	if err = p.sendGetRegionInfo(row); err != nil {
		return
	}
	return p.recvGetRegionInfo()
}

func (p *HbaseClient) sendGetRegionInfo(row Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("getRegionInfo", thrift.CALL, p.SeqId)
	args193 := NewGetRegionInfoArgs()
	args193.Row = row
	err = args193.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *HbaseClient) recvGetRegionInfo() (value *TRegionInfo, io *IOError, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error195 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error196 error
		error196, err = error195.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error196
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result194 := NewGetRegionInfoResult()
	err = result194.Read(iprot)
	iprot.ReadMessageEnd()
	value = result194.Success
	if result194.Io != nil {
		io = result194.Io
	}
	return
}

// Get the specified num versions of the specified columns for the specified table and row.
// Returns an empty list if the row does not exist.
//
// Add by lijianbin
//
// @return TRowResult containing the row and map of columns to TCells
//
// Parameters:
//  - TableName: name of table
//  - Row: row key
//  - Columns: List of columns to return, null for all columns
//  - NumVersions: number of versions to retrieve
//  - Attributes: Get attributes
func (p *HbaseClient) GetRowWithColumnsMaxVer(tableName Text, row Text, columns []Text, numVersions int32, attributes map[Text]Text) (r []*TRowResultWithMultiColVer, io *IOError, err error) {
	if err = p.sendGetRowWithColumnsMaxVer(tableName, row, columns, numVersions, attributes); err != nil {
		return
	}
	return p.recvGetRowWithColumnsMaxVer()
}

func (p *HbaseClient) sendGetRowWithColumnsMaxVer(tableName Text, row Text, columns []Text, numVersions int32, attributes map[Text]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("getRowWithColumnsMaxVer", thrift.CALL, p.SeqId)
	args197 := NewGetRowWithColumnsMaxVerArgs()
	args197.TableName = tableName
	args197.Row = row
	args197.Columns = columns
	args197.NumVersions = numVersions
	args197.Attributes = attributes
	err = args197.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *HbaseClient) recvGetRowWithColumnsMaxVer() (value []*TRowResultWithMultiColVer, io *IOError, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error199 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error200 error
		error200, err = error199.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error200
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result198 := NewGetRowWithColumnsMaxVerResult()
	err = result198.Read(iprot)
	iprot.ReadMessageEnd()
	value = result198.Success
	if result198.Io != nil {
		io = result198.Io
	}
	return
}

// Get the specified num versions of  the specified columns for the specified table and
// row at the specified timestamp. Returns an empty list if the row does not exist.
//
// Add by lijianbin
//
// @return TRowResult containing the row and map of columns to TCells
//
// Parameters:
//  - TableName: name of table
//  - Row: row key
//  - Columns: List of columns to return, null for all columns
//  - Timestamp
//  - NumVersions: number of versions to retrieve
//  - Attributes: Get attributes
func (p *HbaseClient) GetRowWithColumnsTsMaxVer(tableName Text, row Text, columns []Text, timestamp int64, numVersions int32, attributes map[Text]Text) (r []*TRowResultWithMultiColVer, io *IOError, err error) {
	if err = p.sendGetRowWithColumnsTsMaxVer(tableName, row, columns, timestamp, numVersions, attributes); err != nil {
		return
	}
	return p.recvGetRowWithColumnsTsMaxVer()
}

func (p *HbaseClient) sendGetRowWithColumnsTsMaxVer(tableName Text, row Text, columns []Text, timestamp int64, numVersions int32, attributes map[Text]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("getRowWithColumnsTsMaxVer", thrift.CALL, p.SeqId)
	args201 := NewGetRowWithColumnsTsMaxVerArgs()
	args201.TableName = tableName
	args201.Row = row
	args201.Columns = columns
	args201.Timestamp = timestamp
	args201.NumVersions = numVersions
	args201.Attributes = attributes
	err = args201.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *HbaseClient) recvGetRowWithColumnsTsMaxVer() (value []*TRowResultWithMultiColVer, io *IOError, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error203 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error204 error
		error204, err = error203.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error204
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result202 := NewGetRowWithColumnsTsMaxVerResult()
	err = result202.Read(iprot)
	iprot.ReadMessageEnd()
	value = result202.Success
	if result202.Io != nil {
		io = result202.Io
	}
	return
}

type HbaseProcessor struct {
	processorMap map[string]thrift.TProcessorFunction
	handler      Hbase
}

func (p *HbaseProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
	p.processorMap[key] = processor
}

func (p *HbaseProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
	processor, ok = p.processorMap[key]
	return processor, ok
}

func (p *HbaseProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
	return p.processorMap
}

func NewHbaseProcessor(handler Hbase) *HbaseProcessor {

	self205 := &HbaseProcessor{handler: handler, processorMap: make(map[string]thrift.TProcessorFunction)}
	self205.processorMap["enableTable"] = &hbaseProcessorEnableTable{handler: handler}
	self205.processorMap["disableTable"] = &hbaseProcessorDisableTable{handler: handler}
	self205.processorMap["isTableEnabled"] = &hbaseProcessorIsTableEnabled{handler: handler}
	self205.processorMap["compact"] = &hbaseProcessorCompact{handler: handler}
	self205.processorMap["majorCompact"] = &hbaseProcessorMajorCompact{handler: handler}
	self205.processorMap["getTableNames"] = &hbaseProcessorGetTableNames{handler: handler}
	self205.processorMap["getColumnDescriptors"] = &hbaseProcessorGetColumnDescriptors{handler: handler}
	self205.processorMap["getTableRegions"] = &hbaseProcessorGetTableRegions{handler: handler}
	self205.processorMap["createTable"] = &hbaseProcessorCreateTable{handler: handler}
	self205.processorMap["MTCreateTable"] = &hbaseProcessorMTCreateTable{handler: handler}
	self205.processorMap["MTAddColumn"] = &hbaseProcessorMTAddColumn{handler: handler}
	self205.processorMap["MTModifyColumn"] = &hbaseProcessorMTModifyColumn{handler: handler}
	self205.processorMap["MTDeleteColumn"] = &hbaseProcessorMTDeleteColumn{handler: handler}
	self205.processorMap["deleteTable"] = &hbaseProcessorDeleteTable{handler: handler}
	self205.processorMap["get"] = &hbaseProcessorGet{handler: handler}
	self205.processorMap["getVer"] = &hbaseProcessorGetVer{handler: handler}
	self205.processorMap["getVerTs"] = &hbaseProcessorGetVerTs{handler: handler}
	self205.processorMap["getRow"] = &hbaseProcessorGetRow{handler: handler}
	self205.processorMap["getRowWithColumns"] = &hbaseProcessorGetRowWithColumns{handler: handler}
	self205.processorMap["getRowTs"] = &hbaseProcessorGetRowTs{handler: handler}
	self205.processorMap["getRowWithColumnsTs"] = &hbaseProcessorGetRowWithColumnsTs{handler: handler}
	self205.processorMap["getRows"] = &hbaseProcessorGetRows{handler: handler}
	self205.processorMap["getRowsWithColumns"] = &hbaseProcessorGetRowsWithColumns{handler: handler}
	self205.processorMap["getRowsTs"] = &hbaseProcessorGetRowsTs{handler: handler}
	self205.processorMap["getRowsWithColumnsTs"] = &hbaseProcessorGetRowsWithColumnsTs{handler: handler}
	self205.processorMap["mutateRow"] = &hbaseProcessorMutateRow{handler: handler}
	self205.processorMap["mutateRowTs"] = &hbaseProcessorMutateRowTs{handler: handler}
	self205.processorMap["mutateRows"] = &hbaseProcessorMutateRows{handler: handler}
	self205.processorMap["mutateRowsTs"] = &hbaseProcessorMutateRowsTs{handler: handler}
	self205.processorMap["atomicIncrement"] = &hbaseProcessorAtomicIncrement{handler: handler}
	self205.processorMap["deleteAll"] = &hbaseProcessorDeleteAll{handler: handler}
	self205.processorMap["deleteAllTs"] = &hbaseProcessorDeleteAllTs{handler: handler}
	self205.processorMap["deleteAllRow"] = &hbaseProcessorDeleteAllRow{handler: handler}
	self205.processorMap["increment"] = &hbaseProcessorIncrement{handler: handler}
	self205.processorMap["incrementRows"] = &hbaseProcessorIncrementRows{handler: handler}
	self205.processorMap["deleteAllRowTs"] = &hbaseProcessorDeleteAllRowTs{handler: handler}
	self205.processorMap["scannerOpenWithScan"] = &hbaseProcessorScannerOpenWithScan{handler: handler}
	self205.processorMap["scannerOpen"] = &hbaseProcessorScannerOpen{handler: handler}
	self205.processorMap["scannerOpenWithStop"] = &hbaseProcessorScannerOpenWithStop{handler: handler}
	self205.processorMap["scannerOpenWithPrefix"] = &hbaseProcessorScannerOpenWithPrefix{handler: handler}
	self205.processorMap["scannerOpenTs"] = &hbaseProcessorScannerOpenTs{handler: handler}
	self205.processorMap["scannerOpenWithStopTs"] = &hbaseProcessorScannerOpenWithStopTs{handler: handler}
	self205.processorMap["scannerGet"] = &hbaseProcessorScannerGet{handler: handler}
	self205.processorMap["scannerGetList"] = &hbaseProcessorScannerGetList{handler: handler}
	self205.processorMap["scannerClose"] = &hbaseProcessorScannerClose{handler: handler}
	self205.processorMap["getRowOrBefore"] = &hbaseProcessorGetRowOrBefore{handler: handler}
	self205.processorMap["getRegionInfo"] = &hbaseProcessorGetRegionInfo{handler: handler}
	self205.processorMap["getRowWithColumnsMaxVer"] = &hbaseProcessorGetRowWithColumnsMaxVer{handler: handler}
	self205.processorMap["getRowWithColumnsTsMaxVer"] = &hbaseProcessorGetRowWithColumnsTsMaxVer{handler: handler}
	return self205
}

func (p *HbaseProcessor) Process(iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	name, _, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return false, err
	}
	if processor, ok := p.GetProcessorFunction(name); ok {
		return processor.Process(seqId, iprot, oprot)
	}
	iprot.Skip(thrift.STRUCT)
	iprot.ReadMessageEnd()
	x206 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function "+name)
	oprot.WriteMessageBegin(name, thrift.EXCEPTION, seqId)
	x206.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return false, x206

}

type hbaseProcessorEnableTable struct {
	handler Hbase
}

func (p *hbaseProcessorEnableTable) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewEnableTableArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("enableTable", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewEnableTableResult()
	if result.Io, err = p.handler.EnableTable(args.TableName); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing enableTable: "+err.Error())
		oprot.WriteMessageBegin("enableTable", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("enableTable", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorDisableTable struct {
	handler Hbase
}

func (p *hbaseProcessorDisableTable) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewDisableTableArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("disableTable", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewDisableTableResult()
	if result.Io, err = p.handler.DisableTable(args.TableName); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing disableTable: "+err.Error())
		oprot.WriteMessageBegin("disableTable", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("disableTable", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorIsTableEnabled struct {
	handler Hbase
}

func (p *hbaseProcessorIsTableEnabled) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewIsTableEnabledArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("isTableEnabled", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewIsTableEnabledResult()
	if result.Success, result.Io, err = p.handler.IsTableEnabled(args.TableName); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing isTableEnabled: "+err.Error())
		oprot.WriteMessageBegin("isTableEnabled", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("isTableEnabled", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorCompact struct {
	handler Hbase
}

func (p *hbaseProcessorCompact) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewCompactArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("compact", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewCompactResult()
	if result.Io, err = p.handler.Compact(args.TableNameOrRegionName); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing compact: "+err.Error())
		oprot.WriteMessageBegin("compact", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("compact", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorMajorCompact struct {
	handler Hbase
}

func (p *hbaseProcessorMajorCompact) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewMajorCompactArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("majorCompact", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewMajorCompactResult()
	if result.Io, err = p.handler.MajorCompact(args.TableNameOrRegionName); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing majorCompact: "+err.Error())
		oprot.WriteMessageBegin("majorCompact", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("majorCompact", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorGetTableNames struct {
	handler Hbase
}

func (p *hbaseProcessorGetTableNames) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetTableNamesArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getTableNames", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetTableNamesResult()
	if result.Success, result.Io, err = p.handler.GetTableNames(); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getTableNames: "+err.Error())
		oprot.WriteMessageBegin("getTableNames", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("getTableNames", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorGetColumnDescriptors struct {
	handler Hbase
}

func (p *hbaseProcessorGetColumnDescriptors) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetColumnDescriptorsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getColumnDescriptors", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetColumnDescriptorsResult()
	if result.Success, result.Io, err = p.handler.GetColumnDescriptors(args.TableName); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getColumnDescriptors: "+err.Error())
		oprot.WriteMessageBegin("getColumnDescriptors", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("getColumnDescriptors", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorGetTableRegions struct {
	handler Hbase
}

func (p *hbaseProcessorGetTableRegions) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetTableRegionsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getTableRegions", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetTableRegionsResult()
	if result.Success, result.Io, err = p.handler.GetTableRegions(args.TableName); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getTableRegions: "+err.Error())
		oprot.WriteMessageBegin("getTableRegions", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("getTableRegions", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorCreateTable struct {
	handler Hbase
}

func (p *hbaseProcessorCreateTable) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewCreateTableArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("createTable", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewCreateTableResult()
	if result.Io, result.Ia, result.Exist, err = p.handler.CreateTable(args.TableName, args.ColumnFamilies); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing createTable: "+err.Error())
		oprot.WriteMessageBegin("createTable", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("createTable", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorMTCreateTable struct {
	handler Hbase
}

func (p *hbaseProcessorMTCreateTable) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewMTCreateTableArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("MTCreateTable", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewMTCreateTableResult()
	if result.Io, result.Ia, result.Exist, err = p.handler.MTCreateTable(args.TableName, args.SplitKeys, args.ColumnFamilies); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing MTCreateTable: "+err.Error())
		oprot.WriteMessageBegin("MTCreateTable", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("MTCreateTable", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorMTAddColumn struct {
	handler Hbase
}

func (p *hbaseProcessorMTAddColumn) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewMTAddColumnArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("MTAddColumn", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewMTAddColumnResult()
	if result.Io, result.Ia, err = p.handler.MTAddColumn(args.TableName, args.ColumnFamilies); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing MTAddColumn: "+err.Error())
		oprot.WriteMessageBegin("MTAddColumn", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("MTAddColumn", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorMTModifyColumn struct {
	handler Hbase
}

func (p *hbaseProcessorMTModifyColumn) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewMTModifyColumnArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("MTModifyColumn", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewMTModifyColumnResult()
	if result.Io, result.Ia, err = p.handler.MTModifyColumn(args.TableName, args.ColumnFamilies); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing MTModifyColumn: "+err.Error())
		oprot.WriteMessageBegin("MTModifyColumn", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("MTModifyColumn", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorMTDeleteColumn struct {
	handler Hbase
}

func (p *hbaseProcessorMTDeleteColumn) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewMTDeleteColumnArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("MTDeleteColumn", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewMTDeleteColumnResult()
	if result.Io, result.Ia, err = p.handler.MTDeleteColumn(args.TableName, args.ColumnNames); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing MTDeleteColumn: "+err.Error())
		oprot.WriteMessageBegin("MTDeleteColumn", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("MTDeleteColumn", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorDeleteTable struct {
	handler Hbase
}

func (p *hbaseProcessorDeleteTable) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewDeleteTableArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("deleteTable", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewDeleteTableResult()
	if result.Io, err = p.handler.DeleteTable(args.TableName); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing deleteTable: "+err.Error())
		oprot.WriteMessageBegin("deleteTable", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("deleteTable", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorGet struct {
	handler Hbase
}

func (p *hbaseProcessorGet) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("get", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetResult()
	if result.Success, result.Io, err = p.handler.Get(args.TableName, args.Row, args.Column, args.Attributes); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get: "+err.Error())
		oprot.WriteMessageBegin("get", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("get", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorGetVer struct {
	handler Hbase
}

func (p *hbaseProcessorGetVer) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetVerArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getVer", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetVerResult()
	if result.Success, result.Io, err = p.handler.GetVer(args.TableName, args.Row, args.Column, args.NumVersions, args.Attributes); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getVer: "+err.Error())
		oprot.WriteMessageBegin("getVer", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("getVer", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorGetVerTs struct {
	handler Hbase
}

func (p *hbaseProcessorGetVerTs) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetVerTsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getVerTs", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetVerTsResult()
	if result.Success, result.Io, err = p.handler.GetVerTs(args.TableName, args.Row, args.Column, args.Timestamp, args.NumVersions, args.Attributes); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getVerTs: "+err.Error())
		oprot.WriteMessageBegin("getVerTs", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("getVerTs", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorGetRow struct {
	handler Hbase
}

func (p *hbaseProcessorGetRow) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetRowArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getRow", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetRowResult()
	if result.Success, result.Io, err = p.handler.GetRow(args.TableName, args.Row, args.Attributes); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getRow: "+err.Error())
		oprot.WriteMessageBegin("getRow", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("getRow", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorGetRowWithColumns struct {
	handler Hbase
}

func (p *hbaseProcessorGetRowWithColumns) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetRowWithColumnsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getRowWithColumns", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetRowWithColumnsResult()
	if result.Success, result.Io, err = p.handler.GetRowWithColumns(args.TableName, args.Row, args.Columns, args.Attributes); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getRowWithColumns: "+err.Error())
		oprot.WriteMessageBegin("getRowWithColumns", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("getRowWithColumns", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorGetRowTs struct {
	handler Hbase
}

func (p *hbaseProcessorGetRowTs) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetRowTsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getRowTs", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetRowTsResult()
	if result.Success, result.Io, err = p.handler.GetRowTs(args.TableName, args.Row, args.Timestamp, args.Attributes); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getRowTs: "+err.Error())
		oprot.WriteMessageBegin("getRowTs", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("getRowTs", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorGetRowWithColumnsTs struct {
	handler Hbase
}

func (p *hbaseProcessorGetRowWithColumnsTs) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetRowWithColumnsTsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getRowWithColumnsTs", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetRowWithColumnsTsResult()
	if result.Success, result.Io, err = p.handler.GetRowWithColumnsTs(args.TableName, args.Row, args.Columns, args.Timestamp, args.Attributes); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getRowWithColumnsTs: "+err.Error())
		oprot.WriteMessageBegin("getRowWithColumnsTs", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("getRowWithColumnsTs", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorGetRows struct {
	handler Hbase
}

func (p *hbaseProcessorGetRows) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetRowsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getRows", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetRowsResult()
	if result.Success, result.Io, err = p.handler.GetRows(args.TableName, args.Rows, args.Attributes); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getRows: "+err.Error())
		oprot.WriteMessageBegin("getRows", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("getRows", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorGetRowsWithColumns struct {
	handler Hbase
}

func (p *hbaseProcessorGetRowsWithColumns) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetRowsWithColumnsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getRowsWithColumns", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetRowsWithColumnsResult()
	if result.Success, result.Io, err = p.handler.GetRowsWithColumns(args.TableName, args.Rows, args.Columns, args.Attributes); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getRowsWithColumns: "+err.Error())
		oprot.WriteMessageBegin("getRowsWithColumns", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("getRowsWithColumns", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorGetRowsTs struct {
	handler Hbase
}

func (p *hbaseProcessorGetRowsTs) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetRowsTsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getRowsTs", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetRowsTsResult()
	if result.Success, result.Io, err = p.handler.GetRowsTs(args.TableName, args.Rows, args.Timestamp, args.Attributes); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getRowsTs: "+err.Error())
		oprot.WriteMessageBegin("getRowsTs", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("getRowsTs", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorGetRowsWithColumnsTs struct {
	handler Hbase
}

func (p *hbaseProcessorGetRowsWithColumnsTs) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetRowsWithColumnsTsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getRowsWithColumnsTs", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetRowsWithColumnsTsResult()
	if result.Success, result.Io, err = p.handler.GetRowsWithColumnsTs(args.TableName, args.Rows, args.Columns, args.Timestamp, args.Attributes); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getRowsWithColumnsTs: "+err.Error())
		oprot.WriteMessageBegin("getRowsWithColumnsTs", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("getRowsWithColumnsTs", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorMutateRow struct {
	handler Hbase
}

func (p *hbaseProcessorMutateRow) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewMutateRowArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("mutateRow", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewMutateRowResult()
	if result.Io, result.Ia, err = p.handler.MutateRow(args.TableName, args.Row, args.Mutations, args.Attributes); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing mutateRow: "+err.Error())
		oprot.WriteMessageBegin("mutateRow", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("mutateRow", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorMutateRowTs struct {
	handler Hbase
}

func (p *hbaseProcessorMutateRowTs) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewMutateRowTsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("mutateRowTs", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewMutateRowTsResult()
	if result.Io, result.Ia, err = p.handler.MutateRowTs(args.TableName, args.Row, args.Mutations, args.Timestamp, args.Attributes); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing mutateRowTs: "+err.Error())
		oprot.WriteMessageBegin("mutateRowTs", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("mutateRowTs", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorMutateRows struct {
	handler Hbase
}

func (p *hbaseProcessorMutateRows) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewMutateRowsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("mutateRows", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewMutateRowsResult()
	if result.Io, result.Ia, err = p.handler.MutateRows(args.TableName, args.RowBatches, args.Attributes); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing mutateRows: "+err.Error())
		oprot.WriteMessageBegin("mutateRows", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("mutateRows", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorMutateRowsTs struct {
	handler Hbase
}

func (p *hbaseProcessorMutateRowsTs) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewMutateRowsTsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("mutateRowsTs", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewMutateRowsTsResult()
	if result.Io, result.Ia, err = p.handler.MutateRowsTs(args.TableName, args.RowBatches, args.Timestamp, args.Attributes); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing mutateRowsTs: "+err.Error())
		oprot.WriteMessageBegin("mutateRowsTs", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("mutateRowsTs", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorAtomicIncrement struct {
	handler Hbase
}

func (p *hbaseProcessorAtomicIncrement) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewAtomicIncrementArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("atomicIncrement", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewAtomicIncrementResult()
	if result.Success, result.Io, result.Ia, err = p.handler.AtomicIncrement(args.TableName, args.Row, args.Column, args.Value); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing atomicIncrement: "+err.Error())
		oprot.WriteMessageBegin("atomicIncrement", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("atomicIncrement", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorDeleteAll struct {
	handler Hbase
}

func (p *hbaseProcessorDeleteAll) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewDeleteAllArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("deleteAll", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewDeleteAllResult()
	if result.Io, err = p.handler.DeleteAll(args.TableName, args.Row, args.Column, args.Attributes); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing deleteAll: "+err.Error())
		oprot.WriteMessageBegin("deleteAll", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("deleteAll", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorDeleteAllTs struct {
	handler Hbase
}

func (p *hbaseProcessorDeleteAllTs) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewDeleteAllTsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("deleteAllTs", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewDeleteAllTsResult()
	if result.Io, err = p.handler.DeleteAllTs(args.TableName, args.Row, args.Column, args.Timestamp, args.Attributes); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing deleteAllTs: "+err.Error())
		oprot.WriteMessageBegin("deleteAllTs", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("deleteAllTs", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorDeleteAllRow struct {
	handler Hbase
}

func (p *hbaseProcessorDeleteAllRow) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewDeleteAllRowArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("deleteAllRow", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewDeleteAllRowResult()
	if result.Io, err = p.handler.DeleteAllRow(args.TableName, args.Row, args.Attributes); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing deleteAllRow: "+err.Error())
		oprot.WriteMessageBegin("deleteAllRow", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("deleteAllRow", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorIncrement struct {
	handler Hbase
}

func (p *hbaseProcessorIncrement) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewIncrementArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("increment", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewIncrementResult()
	if result.Io, err = p.handler.Increment(args.Increment); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing increment: "+err.Error())
		oprot.WriteMessageBegin("increment", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("increment", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorIncrementRows struct {
	handler Hbase
}

func (p *hbaseProcessorIncrementRows) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewIncrementRowsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("incrementRows", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewIncrementRowsResult()
	if result.Io, err = p.handler.IncrementRows(args.Increments); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing incrementRows: "+err.Error())
		oprot.WriteMessageBegin("incrementRows", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("incrementRows", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorDeleteAllRowTs struct {
	handler Hbase
}

func (p *hbaseProcessorDeleteAllRowTs) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewDeleteAllRowTsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("deleteAllRowTs", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewDeleteAllRowTsResult()
	if result.Io, err = p.handler.DeleteAllRowTs(args.TableName, args.Row, args.Timestamp, args.Attributes); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing deleteAllRowTs: "+err.Error())
		oprot.WriteMessageBegin("deleteAllRowTs", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("deleteAllRowTs", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorScannerOpenWithScan struct {
	handler Hbase
}

func (p *hbaseProcessorScannerOpenWithScan) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewScannerOpenWithScanArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("scannerOpenWithScan", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewScannerOpenWithScanResult()
	if result.Success, result.Io, err = p.handler.ScannerOpenWithScan(args.TableName, args.Scan, args.Attributes); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing scannerOpenWithScan: "+err.Error())
		oprot.WriteMessageBegin("scannerOpenWithScan", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("scannerOpenWithScan", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorScannerOpen struct {
	handler Hbase
}

func (p *hbaseProcessorScannerOpen) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewScannerOpenArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("scannerOpen", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewScannerOpenResult()
	if result.Success, result.Io, err = p.handler.ScannerOpen(args.TableName, args.StartRow, args.Columns, args.Attributes); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing scannerOpen: "+err.Error())
		oprot.WriteMessageBegin("scannerOpen", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("scannerOpen", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorScannerOpenWithStop struct {
	handler Hbase
}

func (p *hbaseProcessorScannerOpenWithStop) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewScannerOpenWithStopArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("scannerOpenWithStop", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewScannerOpenWithStopResult()
	if result.Success, result.Io, err = p.handler.ScannerOpenWithStop(args.TableName, args.StartRow, args.StopRow, args.Columns, args.Attributes); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing scannerOpenWithStop: "+err.Error())
		oprot.WriteMessageBegin("scannerOpenWithStop", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("scannerOpenWithStop", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorScannerOpenWithPrefix struct {
	handler Hbase
}

func (p *hbaseProcessorScannerOpenWithPrefix) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewScannerOpenWithPrefixArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("scannerOpenWithPrefix", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewScannerOpenWithPrefixResult()
	if result.Success, result.Io, err = p.handler.ScannerOpenWithPrefix(args.TableName, args.StartAndPrefix, args.Columns, args.Attributes); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing scannerOpenWithPrefix: "+err.Error())
		oprot.WriteMessageBegin("scannerOpenWithPrefix", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("scannerOpenWithPrefix", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorScannerOpenTs struct {
	handler Hbase
}

func (p *hbaseProcessorScannerOpenTs) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewScannerOpenTsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("scannerOpenTs", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewScannerOpenTsResult()
	if result.Success, result.Io, err = p.handler.ScannerOpenTs(args.TableName, args.StartRow, args.Columns, args.Timestamp, args.Attributes); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing scannerOpenTs: "+err.Error())
		oprot.WriteMessageBegin("scannerOpenTs", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("scannerOpenTs", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorScannerOpenWithStopTs struct {
	handler Hbase
}

func (p *hbaseProcessorScannerOpenWithStopTs) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewScannerOpenWithStopTsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("scannerOpenWithStopTs", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewScannerOpenWithStopTsResult()
	if result.Success, result.Io, err = p.handler.ScannerOpenWithStopTs(args.TableName, args.StartRow, args.StopRow, args.Columns, args.Timestamp, args.Attributes); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing scannerOpenWithStopTs: "+err.Error())
		oprot.WriteMessageBegin("scannerOpenWithStopTs", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("scannerOpenWithStopTs", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorScannerGet struct {
	handler Hbase
}

func (p *hbaseProcessorScannerGet) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewScannerGetArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("scannerGet", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewScannerGetResult()
	if result.Success, result.Io, result.Ia, err = p.handler.ScannerGet(args.Id); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing scannerGet: "+err.Error())
		oprot.WriteMessageBegin("scannerGet", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("scannerGet", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorScannerGetList struct {
	handler Hbase
}

func (p *hbaseProcessorScannerGetList) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewScannerGetListArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("scannerGetList", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewScannerGetListResult()
	if result.Success, result.Io, result.Ia, err = p.handler.ScannerGetList(args.Id, args.NbRows); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing scannerGetList: "+err.Error())
		oprot.WriteMessageBegin("scannerGetList", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("scannerGetList", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorScannerClose struct {
	handler Hbase
}

func (p *hbaseProcessorScannerClose) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewScannerCloseArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("scannerClose", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewScannerCloseResult()
	if result.Io, result.Ia, err = p.handler.ScannerClose(args.Id); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing scannerClose: "+err.Error())
		oprot.WriteMessageBegin("scannerClose", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("scannerClose", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorGetRowOrBefore struct {
	handler Hbase
}

func (p *hbaseProcessorGetRowOrBefore) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetRowOrBeforeArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getRowOrBefore", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetRowOrBeforeResult()
	if result.Success, result.Io, err = p.handler.GetRowOrBefore(args.TableName, args.Row, args.Family); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getRowOrBefore: "+err.Error())
		oprot.WriteMessageBegin("getRowOrBefore", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("getRowOrBefore", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorGetRegionInfo struct {
	handler Hbase
}

func (p *hbaseProcessorGetRegionInfo) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetRegionInfoArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getRegionInfo", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetRegionInfoResult()
	if result.Success, result.Io, err = p.handler.GetRegionInfo(args.Row); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getRegionInfo: "+err.Error())
		oprot.WriteMessageBegin("getRegionInfo", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("getRegionInfo", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorGetRowWithColumnsMaxVer struct {
	handler Hbase
}

func (p *hbaseProcessorGetRowWithColumnsMaxVer) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetRowWithColumnsMaxVerArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getRowWithColumnsMaxVer", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetRowWithColumnsMaxVerResult()
	if result.Success, result.Io, err = p.handler.GetRowWithColumnsMaxVer(args.TableName, args.Row, args.Columns, args.NumVersions, args.Attributes); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getRowWithColumnsMaxVer: "+err.Error())
		oprot.WriteMessageBegin("getRowWithColumnsMaxVer", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("getRowWithColumnsMaxVer", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorGetRowWithColumnsTsMaxVer struct {
	handler Hbase
}

func (p *hbaseProcessorGetRowWithColumnsTsMaxVer) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetRowWithColumnsTsMaxVerArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getRowWithColumnsTsMaxVer", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetRowWithColumnsTsMaxVerResult()
	if result.Success, result.Io, err = p.handler.GetRowWithColumnsTsMaxVer(args.TableName, args.Row, args.Columns, args.Timestamp, args.NumVersions, args.Attributes); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getRowWithColumnsTsMaxVer: "+err.Error())
		oprot.WriteMessageBegin("getRowWithColumnsTsMaxVer", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("getRowWithColumnsTsMaxVer", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

// HELPER FUNCTIONS AND STRUCTURES

type EnableTableArgs struct {
	TableName Bytes `thrift:"tableName,1"`
}

func NewEnableTableArgs() *EnableTableArgs {
	return &EnableTableArgs{}
}

func (p *EnableTableArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *EnableTableArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.TableName = Bytes(v)
	}
	return nil
}

func (p *EnableTableArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("enableTable_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *EnableTableArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.BINARY, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *EnableTableArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("EnableTableArgs(%+v)", *p)
}

type EnableTableResult struct {
	Io *IOError `thrift:"io,1"`
}

func NewEnableTableResult() *EnableTableResult {
	return &EnableTableResult{}
}

func (p *EnableTableResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *EnableTableResult) readField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io)
	}
	return nil
}

func (p *EnableTableResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("enableTable_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *EnableTableResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *EnableTableResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("EnableTableResult(%+v)", *p)
}

type DisableTableArgs struct {
	TableName Bytes `thrift:"tableName,1"`
}

func NewDisableTableArgs() *DisableTableArgs {
	return &DisableTableArgs{}
}

func (p *DisableTableArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DisableTableArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.TableName = Bytes(v)
	}
	return nil
}

func (p *DisableTableArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("disableTable_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *DisableTableArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.BINARY, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *DisableTableArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DisableTableArgs(%+v)", *p)
}

type DisableTableResult struct {
	Io *IOError `thrift:"io,1"`
}

func NewDisableTableResult() *DisableTableResult {
	return &DisableTableResult{}
}

func (p *DisableTableResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DisableTableResult) readField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io)
	}
	return nil
}

func (p *DisableTableResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("disableTable_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *DisableTableResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *DisableTableResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DisableTableResult(%+v)", *p)
}

type IsTableEnabledArgs struct {
	TableName Bytes `thrift:"tableName,1"`
}

func NewIsTableEnabledArgs() *IsTableEnabledArgs {
	return &IsTableEnabledArgs{}
}

func (p *IsTableEnabledArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *IsTableEnabledArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.TableName = Bytes(v)
	}
	return nil
}

func (p *IsTableEnabledArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("isTableEnabled_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *IsTableEnabledArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.BINARY, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *IsTableEnabledArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("IsTableEnabledArgs(%+v)", *p)
}

type IsTableEnabledResult struct {
	Success bool     `thrift:"success,0"`
	Io      *IOError `thrift:"io,1"`
}

func NewIsTableEnabledResult() *IsTableEnabledResult {
	return &IsTableEnabledResult{}
}

func (p *IsTableEnabledResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *IsTableEnabledResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *IsTableEnabledResult) readField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io)
	}
	return nil
}

func (p *IsTableEnabledResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("isTableEnabled_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *IsTableEnabledResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.BOOL, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteBool(bool(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *IsTableEnabledResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *IsTableEnabledResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("IsTableEnabledResult(%+v)", *p)
}

type CompactArgs struct {
	TableNameOrRegionName Bytes `thrift:"tableNameOrRegionName,1"`
}

func NewCompactArgs() *CompactArgs {
	return &CompactArgs{}
}

func (p *CompactArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CompactArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.TableNameOrRegionName = Bytes(v)
	}
	return nil
}

func (p *CompactArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("compact_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CompactArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableNameOrRegionName != nil {
		if err := oprot.WriteFieldBegin("tableNameOrRegionName", thrift.BINARY, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableNameOrRegionName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableNameOrRegionName); err != nil {
			return fmt.Errorf("%T.tableNameOrRegionName (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableNameOrRegionName: %s", p, err)
		}
	}
	return err
}

func (p *CompactArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CompactArgs(%+v)", *p)
}

type CompactResult struct {
	Io *IOError `thrift:"io,1"`
}

func NewCompactResult() *CompactResult {
	return &CompactResult{}
}

func (p *CompactResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CompactResult) readField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io)
	}
	return nil
}

func (p *CompactResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("compact_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CompactResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *CompactResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CompactResult(%+v)", *p)
}

type MajorCompactArgs struct {
	TableNameOrRegionName Bytes `thrift:"tableNameOrRegionName,1"`
}

func NewMajorCompactArgs() *MajorCompactArgs {
	return &MajorCompactArgs{}
}

func (p *MajorCompactArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MajorCompactArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.TableNameOrRegionName = Bytes(v)
	}
	return nil
}

func (p *MajorCompactArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("majorCompact_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *MajorCompactArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableNameOrRegionName != nil {
		if err := oprot.WriteFieldBegin("tableNameOrRegionName", thrift.BINARY, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableNameOrRegionName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableNameOrRegionName); err != nil {
			return fmt.Errorf("%T.tableNameOrRegionName (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableNameOrRegionName: %s", p, err)
		}
	}
	return err
}

func (p *MajorCompactArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MajorCompactArgs(%+v)", *p)
}

type MajorCompactResult struct {
	Io *IOError `thrift:"io,1"`
}

func NewMajorCompactResult() *MajorCompactResult {
	return &MajorCompactResult{}
}

func (p *MajorCompactResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MajorCompactResult) readField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io)
	}
	return nil
}

func (p *MajorCompactResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("majorCompact_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *MajorCompactResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *MajorCompactResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MajorCompactResult(%+v)", *p)
}

type GetTableNamesArgs struct {
}

func NewGetTableNamesArgs() *GetTableNamesArgs {
	return &GetTableNamesArgs{}
}

func (p *GetTableNamesArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTableNamesArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTableNames_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTableNamesArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTableNamesArgs(%+v)", *p)
}

type GetTableNamesResult struct {
	Success []Text   `thrift:"success,0"`
	Io      *IOError `thrift:"io,1"`
}

func NewGetTableNamesResult() *GetTableNamesResult {
	return &GetTableNamesResult{}
}

func (p *GetTableNamesResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTableNamesResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]Text, 0, size)
	for i := 0; i < size; i++ {
		var _elem207 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_elem207 = Text(v)
		}
		p.Success = append(p.Success, _elem207)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *GetTableNamesResult) readField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io)
	}
	return nil
}

func (p *GetTableNamesResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTableNames_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTableNamesResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.BINARY, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetTableNamesResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetTableNamesResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTableNamesResult(%+v)", *p)
}

type GetColumnDescriptorsArgs struct {
	TableName Text `thrift:"tableName,1"`
}

func NewGetColumnDescriptorsArgs() *GetColumnDescriptorsArgs {
	return &GetColumnDescriptorsArgs{}
}

func (p *GetColumnDescriptorsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetColumnDescriptorsArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.TableName = Text(v)
	}
	return nil
}

func (p *GetColumnDescriptorsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getColumnDescriptors_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetColumnDescriptorsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.BINARY, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *GetColumnDescriptorsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetColumnDescriptorsArgs(%+v)", *p)
}

type GetColumnDescriptorsResult struct {
	Success map[Text]*ColumnDescriptor `thrift:"success,0"`
	Io      *IOError                   `thrift:"io,1"`
}

func NewGetColumnDescriptorsResult() *GetColumnDescriptorsResult {
	return &GetColumnDescriptorsResult{}
}

func (p *GetColumnDescriptorsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetColumnDescriptorsResult) readField0(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s")
	}
	p.Success = make(map[Text]*ColumnDescriptor, size)
	for i := 0; i < size; i++ {
		var _key208 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_key208 = Text(v)
		}
		_val209 := NewColumnDescriptor()
		if err := _val209.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _val209)
		}
		p.Success[_key208] = _val209
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s")
	}
	return nil
}

func (p *GetColumnDescriptorsResult) readField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io)
	}
	return nil
}

func (p *GetColumnDescriptorsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getColumnDescriptors_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetColumnDescriptorsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.MAP, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.BINARY, thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing map begin: %s")
		}
		for k, v := range p.Success {
			if err := oprot.WriteBinary(k); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetColumnDescriptorsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetColumnDescriptorsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetColumnDescriptorsResult(%+v)", *p)
}

type GetTableRegionsArgs struct {
	TableName Text `thrift:"tableName,1"`
}

func NewGetTableRegionsArgs() *GetTableRegionsArgs {
	return &GetTableRegionsArgs{}
}

func (p *GetTableRegionsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTableRegionsArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.TableName = Text(v)
	}
	return nil
}

func (p *GetTableRegionsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTableRegions_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTableRegionsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.BINARY, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *GetTableRegionsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTableRegionsArgs(%+v)", *p)
}

type GetTableRegionsResult struct {
	Success []*TRegionInfo `thrift:"success,0"`
	Io      *IOError       `thrift:"io,1"`
}

func NewGetTableRegionsResult() *GetTableRegionsResult {
	return &GetTableRegionsResult{}
}

func (p *GetTableRegionsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTableRegionsResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]*TRegionInfo, 0, size)
	for i := 0; i < size; i++ {
		_elem210 := NewTRegionInfo()
		if err := _elem210.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem210)
		}
		p.Success = append(p.Success, _elem210)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *GetTableRegionsResult) readField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io)
	}
	return nil
}

func (p *GetTableRegionsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTableRegions_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTableRegionsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetTableRegionsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetTableRegionsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTableRegionsResult(%+v)", *p)
}

type CreateTableArgs struct {
	TableName      Text                `thrift:"tableName,1"`
	ColumnFamilies []*ColumnDescriptor `thrift:"columnFamilies,2"`
}

func NewCreateTableArgs() *CreateTableArgs {
	return &CreateTableArgs{}
}

func (p *CreateTableArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CreateTableArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.TableName = Text(v)
	}
	return nil
}

func (p *CreateTableArgs) readField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.ColumnFamilies = make([]*ColumnDescriptor, 0, size)
	for i := 0; i < size; i++ {
		_elem211 := NewColumnDescriptor()
		if err := _elem211.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem211)
		}
		p.ColumnFamilies = append(p.ColumnFamilies, _elem211)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *CreateTableArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("createTable_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CreateTableArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.BINARY, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *CreateTableArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.ColumnFamilies != nil {
		if err := oprot.WriteFieldBegin("columnFamilies", thrift.LIST, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:columnFamilies: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.ColumnFamilies)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.ColumnFamilies {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:columnFamilies: %s", p, err)
		}
	}
	return err
}

func (p *CreateTableArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CreateTableArgs(%+v)", *p)
}

type CreateTableResult struct {
	Io    *IOError         `thrift:"io,1"`
	Ia    *IllegalArgument `thrift:"ia,2"`
	Exist *AlreadyExists   `thrift:"exist,3"`
}

func NewCreateTableResult() *CreateTableResult {
	return &CreateTableResult{}
}

func (p *CreateTableResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CreateTableResult) readField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io)
	}
	return nil
}

func (p *CreateTableResult) readField2(iprot thrift.TProtocol) error {
	p.Ia = NewIllegalArgument()
	if err := p.Ia.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ia)
	}
	return nil
}

func (p *CreateTableResult) readField3(iprot thrift.TProtocol) error {
	p.Exist = NewAlreadyExists()
	if err := p.Exist.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Exist)
	}
	return nil
}

func (p *CreateTableResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("createTable_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Exist != nil:
		if err := p.writeField3(oprot); err != nil {
			return err
		}
	case p.Ia != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CreateTableResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *CreateTableResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ia != nil {
		if err := oprot.WriteFieldBegin("ia", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ia: %s", p, err)
		}
		if err := p.Ia.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ia)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ia: %s", p, err)
		}
	}
	return err
}

func (p *CreateTableResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Exist != nil {
		if err := oprot.WriteFieldBegin("exist", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:exist: %s", p, err)
		}
		if err := p.Exist.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Exist)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:exist: %s", p, err)
		}
	}
	return err
}

func (p *CreateTableResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CreateTableResult(%+v)", *p)
}

type MTCreateTableArgs struct {
	TableName      Text                  `thrift:"tableName,1"`
	SplitKeys      []Text                `thrift:"splitKeys,2"`
	ColumnFamilies []*MTColumnDescriptor `thrift:"columnFamilies,3"`
}

func NewMTCreateTableArgs() *MTCreateTableArgs {
	return &MTCreateTableArgs{}
}

func (p *MTCreateTableArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MTCreateTableArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.TableName = Text(v)
	}
	return nil
}

func (p *MTCreateTableArgs) readField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.SplitKeys = make([]Text, 0, size)
	for i := 0; i < size; i++ {
		var _elem212 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_elem212 = Text(v)
		}
		p.SplitKeys = append(p.SplitKeys, _elem212)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *MTCreateTableArgs) readField3(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.ColumnFamilies = make([]*MTColumnDescriptor, 0, size)
	for i := 0; i < size; i++ {
		_elem213 := NewMTColumnDescriptor()
		if err := _elem213.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem213)
		}
		p.ColumnFamilies = append(p.ColumnFamilies, _elem213)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *MTCreateTableArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("MTCreateTable_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *MTCreateTableArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.BINARY, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *MTCreateTableArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.SplitKeys != nil {
		if err := oprot.WriteFieldBegin("splitKeys", thrift.LIST, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:splitKeys: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.BINARY, len(p.SplitKeys)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.SplitKeys {
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:splitKeys: %s", p, err)
		}
	}
	return err
}

func (p *MTCreateTableArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.ColumnFamilies != nil {
		if err := oprot.WriteFieldBegin("columnFamilies", thrift.LIST, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:columnFamilies: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.ColumnFamilies)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.ColumnFamilies {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:columnFamilies: %s", p, err)
		}
	}
	return err
}

func (p *MTCreateTableArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MTCreateTableArgs(%+v)", *p)
}

type MTCreateTableResult struct {
	Io    *IOError         `thrift:"io,1"`
	Ia    *IllegalArgument `thrift:"ia,2"`
	Exist *AlreadyExists   `thrift:"exist,3"`
}

func NewMTCreateTableResult() *MTCreateTableResult {
	return &MTCreateTableResult{}
}

func (p *MTCreateTableResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MTCreateTableResult) readField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io)
	}
	return nil
}

func (p *MTCreateTableResult) readField2(iprot thrift.TProtocol) error {
	p.Ia = NewIllegalArgument()
	if err := p.Ia.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ia)
	}
	return nil
}

func (p *MTCreateTableResult) readField3(iprot thrift.TProtocol) error {
	p.Exist = NewAlreadyExists()
	if err := p.Exist.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Exist)
	}
	return nil
}

func (p *MTCreateTableResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("MTCreateTable_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Exist != nil:
		if err := p.writeField3(oprot); err != nil {
			return err
		}
	case p.Ia != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *MTCreateTableResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *MTCreateTableResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ia != nil {
		if err := oprot.WriteFieldBegin("ia", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ia: %s", p, err)
		}
		if err := p.Ia.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ia)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ia: %s", p, err)
		}
	}
	return err
}

func (p *MTCreateTableResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Exist != nil {
		if err := oprot.WriteFieldBegin("exist", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:exist: %s", p, err)
		}
		if err := p.Exist.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Exist)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:exist: %s", p, err)
		}
	}
	return err
}

func (p *MTCreateTableResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MTCreateTableResult(%+v)", *p)
}

type MTAddColumnArgs struct {
	TableName      Text                  `thrift:"tableName,1"`
	ColumnFamilies []*MTColumnDescriptor `thrift:"columnFamilies,2"`
}

func NewMTAddColumnArgs() *MTAddColumnArgs {
	return &MTAddColumnArgs{}
}

func (p *MTAddColumnArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MTAddColumnArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.TableName = Text(v)
	}
	return nil
}

func (p *MTAddColumnArgs) readField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.ColumnFamilies = make([]*MTColumnDescriptor, 0, size)
	for i := 0; i < size; i++ {
		_elem214 := NewMTColumnDescriptor()
		if err := _elem214.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem214)
		}
		p.ColumnFamilies = append(p.ColumnFamilies, _elem214)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *MTAddColumnArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("MTAddColumn_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *MTAddColumnArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.BINARY, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *MTAddColumnArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.ColumnFamilies != nil {
		if err := oprot.WriteFieldBegin("columnFamilies", thrift.LIST, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:columnFamilies: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.ColumnFamilies)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.ColumnFamilies {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:columnFamilies: %s", p, err)
		}
	}
	return err
}

func (p *MTAddColumnArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MTAddColumnArgs(%+v)", *p)
}

type MTAddColumnResult struct {
	Io *IOError         `thrift:"io,1"`
	Ia *IllegalArgument `thrift:"ia,2"`
}

func NewMTAddColumnResult() *MTAddColumnResult {
	return &MTAddColumnResult{}
}

func (p *MTAddColumnResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MTAddColumnResult) readField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io)
	}
	return nil
}

func (p *MTAddColumnResult) readField2(iprot thrift.TProtocol) error {
	p.Ia = NewIllegalArgument()
	if err := p.Ia.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ia)
	}
	return nil
}

func (p *MTAddColumnResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("MTAddColumn_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Ia != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *MTAddColumnResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *MTAddColumnResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ia != nil {
		if err := oprot.WriteFieldBegin("ia", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ia: %s", p, err)
		}
		if err := p.Ia.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ia)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ia: %s", p, err)
		}
	}
	return err
}

func (p *MTAddColumnResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MTAddColumnResult(%+v)", *p)
}

type MTModifyColumnArgs struct {
	TableName      Text                  `thrift:"tableName,1"`
	ColumnFamilies []*MTColumnDescriptor `thrift:"columnFamilies,2"`
}

func NewMTModifyColumnArgs() *MTModifyColumnArgs {
	return &MTModifyColumnArgs{}
}

func (p *MTModifyColumnArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MTModifyColumnArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.TableName = Text(v)
	}
	return nil
}

func (p *MTModifyColumnArgs) readField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.ColumnFamilies = make([]*MTColumnDescriptor, 0, size)
	for i := 0; i < size; i++ {
		_elem215 := NewMTColumnDescriptor()
		if err := _elem215.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem215)
		}
		p.ColumnFamilies = append(p.ColumnFamilies, _elem215)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *MTModifyColumnArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("MTModifyColumn_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *MTModifyColumnArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.BINARY, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *MTModifyColumnArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.ColumnFamilies != nil {
		if err := oprot.WriteFieldBegin("columnFamilies", thrift.LIST, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:columnFamilies: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.ColumnFamilies)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.ColumnFamilies {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:columnFamilies: %s", p, err)
		}
	}
	return err
}

func (p *MTModifyColumnArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MTModifyColumnArgs(%+v)", *p)
}

type MTModifyColumnResult struct {
	Io *IOError         `thrift:"io,1"`
	Ia *IllegalArgument `thrift:"ia,2"`
}

func NewMTModifyColumnResult() *MTModifyColumnResult {
	return &MTModifyColumnResult{}
}

func (p *MTModifyColumnResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MTModifyColumnResult) readField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io)
	}
	return nil
}

func (p *MTModifyColumnResult) readField2(iprot thrift.TProtocol) error {
	p.Ia = NewIllegalArgument()
	if err := p.Ia.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ia)
	}
	return nil
}

func (p *MTModifyColumnResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("MTModifyColumn_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Ia != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *MTModifyColumnResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *MTModifyColumnResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ia != nil {
		if err := oprot.WriteFieldBegin("ia", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ia: %s", p, err)
		}
		if err := p.Ia.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ia)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ia: %s", p, err)
		}
	}
	return err
}

func (p *MTModifyColumnResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MTModifyColumnResult(%+v)", *p)
}

type MTDeleteColumnArgs struct {
	TableName   Text     `thrift:"tableName,1"`
	ColumnNames []string `thrift:"columnNames,2"`
}

func NewMTDeleteColumnArgs() *MTDeleteColumnArgs {
	return &MTDeleteColumnArgs{}
}

func (p *MTDeleteColumnArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MTDeleteColumnArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.TableName = Text(v)
	}
	return nil
}

func (p *MTDeleteColumnArgs) readField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.ColumnNames = make([]string, 0, size)
	for i := 0; i < size; i++ {
		var _elem216 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_elem216 = v
		}
		p.ColumnNames = append(p.ColumnNames, _elem216)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *MTDeleteColumnArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("MTDeleteColumn_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *MTDeleteColumnArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.BINARY, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *MTDeleteColumnArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.ColumnNames != nil {
		if err := oprot.WriteFieldBegin("columnNames", thrift.LIST, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:columnNames: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRING, len(p.ColumnNames)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.ColumnNames {
			if err := oprot.WriteString(string(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:columnNames: %s", p, err)
		}
	}
	return err
}

func (p *MTDeleteColumnArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MTDeleteColumnArgs(%+v)", *p)
}

type MTDeleteColumnResult struct {
	Io *IOError         `thrift:"io,1"`
	Ia *IllegalArgument `thrift:"ia,2"`
}

func NewMTDeleteColumnResult() *MTDeleteColumnResult {
	return &MTDeleteColumnResult{}
}

func (p *MTDeleteColumnResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MTDeleteColumnResult) readField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io)
	}
	return nil
}

func (p *MTDeleteColumnResult) readField2(iprot thrift.TProtocol) error {
	p.Ia = NewIllegalArgument()
	if err := p.Ia.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ia)
	}
	return nil
}

func (p *MTDeleteColumnResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("MTDeleteColumn_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Ia != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *MTDeleteColumnResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *MTDeleteColumnResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ia != nil {
		if err := oprot.WriteFieldBegin("ia", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ia: %s", p, err)
		}
		if err := p.Ia.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ia)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ia: %s", p, err)
		}
	}
	return err
}

func (p *MTDeleteColumnResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MTDeleteColumnResult(%+v)", *p)
}

type DeleteTableArgs struct {
	TableName Text `thrift:"tableName,1"`
}

func NewDeleteTableArgs() *DeleteTableArgs {
	return &DeleteTableArgs{}
}

func (p *DeleteTableArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteTableArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.TableName = Text(v)
	}
	return nil
}

func (p *DeleteTableArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteTable_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteTableArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.BINARY, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *DeleteTableArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteTableArgs(%+v)", *p)
}

type DeleteTableResult struct {
	Io *IOError `thrift:"io,1"`
}

func NewDeleteTableResult() *DeleteTableResult {
	return &DeleteTableResult{}
}

func (p *DeleteTableResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteTableResult) readField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io)
	}
	return nil
}

func (p *DeleteTableResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteTable_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteTableResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *DeleteTableResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteTableResult(%+v)", *p)
}

type GetArgs struct {
	TableName  Text          `thrift:"tableName,1"`
	Row        Text          `thrift:"row,2"`
	Column     Text          `thrift:"column,3"`
	Attributes map[Text]Text `thrift:"attributes,4"`
}

func NewGetArgs() *GetArgs {
	return &GetArgs{}
}

func (p *GetArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.TableName = Text(v)
	}
	return nil
}

func (p *GetArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Row = Text(v)
	}
	return nil
}

func (p *GetArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.Column = Text(v)
	}
	return nil
}

func (p *GetArgs) readField4(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s")
	}
	p.Attributes = make(map[Text]Text, size)
	for i := 0; i < size; i++ {
		var _key217 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_key217 = Text(v)
		}
		var _val218 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_val218 = Text(v)
		}
		p.Attributes[_key217] = _val218
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s")
	}
	return nil
}

func (p *GetArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.BINARY, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *GetArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Row != nil {
		if err := oprot.WriteFieldBegin("row", thrift.BINARY, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Row); err != nil {
			return fmt.Errorf("%T.row (2) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:row: %s", p, err)
		}
	}
	return err
}

func (p *GetArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Column != nil {
		if err := oprot.WriteFieldBegin("column", thrift.BINARY, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:column: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Column); err != nil {
			return fmt.Errorf("%T.column (3) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:column: %s", p, err)
		}
	}
	return err
}

func (p *GetArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if p.Attributes != nil {
		if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:attributes: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.BINARY, thrift.BINARY, len(p.Attributes)); err != nil {
			return fmt.Errorf("error writing map begin: %s")
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteBinary(k); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:attributes: %s", p, err)
		}
	}
	return err
}

func (p *GetArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetArgs(%+v)", *p)
}

type GetResult struct {
	Success []*TCell `thrift:"success,0"`
	Io      *IOError `thrift:"io,1"`
}

func NewGetResult() *GetResult {
	return &GetResult{}
}

func (p *GetResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]*TCell, 0, size)
	for i := 0; i < size; i++ {
		_elem219 := NewTCell()
		if err := _elem219.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem219)
		}
		p.Success = append(p.Success, _elem219)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *GetResult) readField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io)
	}
	return nil
}

func (p *GetResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetResult(%+v)", *p)
}

type GetVerArgs struct {
	TableName   Text          `thrift:"tableName,1"`
	Row         Text          `thrift:"row,2"`
	Column      Text          `thrift:"column,3"`
	NumVersions int32         `thrift:"numVersions,4"`
	Attributes  map[Text]Text `thrift:"attributes,5"`
}

func NewGetVerArgs() *GetVerArgs {
	return &GetVerArgs{}
}

func (p *GetVerArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.readField5(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetVerArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.TableName = Text(v)
	}
	return nil
}

func (p *GetVerArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Row = Text(v)
	}
	return nil
}

func (p *GetVerArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.Column = Text(v)
	}
	return nil
}

func (p *GetVerArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 4: %s")
	} else {
		p.NumVersions = v
	}
	return nil
}

func (p *GetVerArgs) readField5(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s")
	}
	p.Attributes = make(map[Text]Text, size)
	for i := 0; i < size; i++ {
		var _key220 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_key220 = Text(v)
		}
		var _val221 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_val221 = Text(v)
		}
		p.Attributes[_key220] = _val221
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s")
	}
	return nil
}

func (p *GetVerArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getVer_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetVerArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.BINARY, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *GetVerArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Row != nil {
		if err := oprot.WriteFieldBegin("row", thrift.BINARY, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Row); err != nil {
			return fmt.Errorf("%T.row (2) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:row: %s", p, err)
		}
	}
	return err
}

func (p *GetVerArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Column != nil {
		if err := oprot.WriteFieldBegin("column", thrift.BINARY, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:column: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Column); err != nil {
			return fmt.Errorf("%T.column (3) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:column: %s", p, err)
		}
	}
	return err
}

func (p *GetVerArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("numVersions", thrift.I32, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:numVersions: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.NumVersions)); err != nil {
		return fmt.Errorf("%T.numVersions (4) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:numVersions: %s", p, err)
	}
	return err
}

func (p *GetVerArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if p.Attributes != nil {
		if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 5); err != nil {
			return fmt.Errorf("%T write field begin error 5:attributes: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.BINARY, thrift.BINARY, len(p.Attributes)); err != nil {
			return fmt.Errorf("error writing map begin: %s")
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteBinary(k); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 5:attributes: %s", p, err)
		}
	}
	return err
}

func (p *GetVerArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetVerArgs(%+v)", *p)
}

type GetVerResult struct {
	Success []*TCell `thrift:"success,0"`
	Io      *IOError `thrift:"io,1"`
}

func NewGetVerResult() *GetVerResult {
	return &GetVerResult{}
}

func (p *GetVerResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetVerResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]*TCell, 0, size)
	for i := 0; i < size; i++ {
		_elem222 := NewTCell()
		if err := _elem222.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem222)
		}
		p.Success = append(p.Success, _elem222)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *GetVerResult) readField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io)
	}
	return nil
}

func (p *GetVerResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getVer_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetVerResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetVerResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetVerResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetVerResult(%+v)", *p)
}

type GetVerTsArgs struct {
	TableName   Text          `thrift:"tableName,1"`
	Row         Text          `thrift:"row,2"`
	Column      Text          `thrift:"column,3"`
	Timestamp   int64         `thrift:"timestamp,4"`
	NumVersions int32         `thrift:"numVersions,5"`
	Attributes  map[Text]Text `thrift:"attributes,6"`
}

func NewGetVerTsArgs() *GetVerTsArgs {
	return &GetVerTsArgs{}
}

func (p *GetVerTsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.readField5(iprot); err != nil {
				return err
			}
		case 6:
			if err := p.readField6(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetVerTsArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.TableName = Text(v)
	}
	return nil
}

func (p *GetVerTsArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Row = Text(v)
	}
	return nil
}

func (p *GetVerTsArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.Column = Text(v)
	}
	return nil
}

func (p *GetVerTsArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 4: %s")
	} else {
		p.Timestamp = v
	}
	return nil
}

func (p *GetVerTsArgs) readField5(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 5: %s")
	} else {
		p.NumVersions = v
	}
	return nil
}

func (p *GetVerTsArgs) readField6(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s")
	}
	p.Attributes = make(map[Text]Text, size)
	for i := 0; i < size; i++ {
		var _key223 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_key223 = Text(v)
		}
		var _val224 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_val224 = Text(v)
		}
		p.Attributes[_key223] = _val224
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s")
	}
	return nil
}

func (p *GetVerTsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getVerTs_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := p.writeField6(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetVerTsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.BINARY, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *GetVerTsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Row != nil {
		if err := oprot.WriteFieldBegin("row", thrift.BINARY, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Row); err != nil {
			return fmt.Errorf("%T.row (2) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:row: %s", p, err)
		}
	}
	return err
}

func (p *GetVerTsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Column != nil {
		if err := oprot.WriteFieldBegin("column", thrift.BINARY, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:column: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Column); err != nil {
			return fmt.Errorf("%T.column (3) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:column: %s", p, err)
		}
	}
	return err
}

func (p *GetVerTsArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("timestamp", thrift.I64, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:timestamp: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Timestamp)); err != nil {
		return fmt.Errorf("%T.timestamp (4) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:timestamp: %s", p, err)
	}
	return err
}

func (p *GetVerTsArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("numVersions", thrift.I32, 5); err != nil {
		return fmt.Errorf("%T write field begin error 5:numVersions: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.NumVersions)); err != nil {
		return fmt.Errorf("%T.numVersions (5) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 5:numVersions: %s", p, err)
	}
	return err
}

func (p *GetVerTsArgs) writeField6(oprot thrift.TProtocol) (err error) {
	if p.Attributes != nil {
		if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 6); err != nil {
			return fmt.Errorf("%T write field begin error 6:attributes: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.BINARY, thrift.BINARY, len(p.Attributes)); err != nil {
			return fmt.Errorf("error writing map begin: %s")
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteBinary(k); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 6:attributes: %s", p, err)
		}
	}
	return err
}

func (p *GetVerTsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetVerTsArgs(%+v)", *p)
}

type GetVerTsResult struct {
	Success []*TCell `thrift:"success,0"`
	Io      *IOError `thrift:"io,1"`
}

func NewGetVerTsResult() *GetVerTsResult {
	return &GetVerTsResult{}
}

func (p *GetVerTsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetVerTsResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]*TCell, 0, size)
	for i := 0; i < size; i++ {
		_elem225 := NewTCell()
		if err := _elem225.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem225)
		}
		p.Success = append(p.Success, _elem225)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *GetVerTsResult) readField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io)
	}
	return nil
}

func (p *GetVerTsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getVerTs_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetVerTsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetVerTsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetVerTsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetVerTsResult(%+v)", *p)
}

type GetRowArgs struct {
	TableName  Text          `thrift:"tableName,1"`
	Row        Text          `thrift:"row,2"`
	Attributes map[Text]Text `thrift:"attributes,3"`
}

func NewGetRowArgs() *GetRowArgs {
	return &GetRowArgs{}
}

func (p *GetRowArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.TableName = Text(v)
	}
	return nil
}

func (p *GetRowArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Row = Text(v)
	}
	return nil
}

func (p *GetRowArgs) readField3(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s")
	}
	p.Attributes = make(map[Text]Text, size)
	for i := 0; i < size; i++ {
		var _key226 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_key226 = Text(v)
		}
		var _val227 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_val227 = Text(v)
		}
		p.Attributes[_key226] = _val227
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s")
	}
	return nil
}

func (p *GetRowArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRow_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.BINARY, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *GetRowArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Row != nil {
		if err := oprot.WriteFieldBegin("row", thrift.BINARY, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Row); err != nil {
			return fmt.Errorf("%T.row (2) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:row: %s", p, err)
		}
	}
	return err
}

func (p *GetRowArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Attributes != nil {
		if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:attributes: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.BINARY, thrift.BINARY, len(p.Attributes)); err != nil {
			return fmt.Errorf("error writing map begin: %s")
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteBinary(k); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:attributes: %s", p, err)
		}
	}
	return err
}

func (p *GetRowArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowArgs(%+v)", *p)
}

type GetRowResult struct {
	Success []*TRowResult `thrift:"success,0"`
	Io      *IOError      `thrift:"io,1"`
}

func NewGetRowResult() *GetRowResult {
	return &GetRowResult{}
}

func (p *GetRowResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]*TRowResult, 0, size)
	for i := 0; i < size; i++ {
		_elem228 := NewTRowResult()
		if err := _elem228.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem228)
		}
		p.Success = append(p.Success, _elem228)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *GetRowResult) readField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io)
	}
	return nil
}

func (p *GetRowResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRow_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetRowResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetRowResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowResult(%+v)", *p)
}

type GetRowWithColumnsArgs struct {
	TableName  Text          `thrift:"tableName,1"`
	Row        Text          `thrift:"row,2"`
	Columns    []Text        `thrift:"columns,3"`
	Attributes map[Text]Text `thrift:"attributes,4"`
}

func NewGetRowWithColumnsArgs() *GetRowWithColumnsArgs {
	return &GetRowWithColumnsArgs{}
}

func (p *GetRowWithColumnsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowWithColumnsArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.TableName = Text(v)
	}
	return nil
}

func (p *GetRowWithColumnsArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Row = Text(v)
	}
	return nil
}

func (p *GetRowWithColumnsArgs) readField3(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Columns = make([]Text, 0, size)
	for i := 0; i < size; i++ {
		var _elem229 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_elem229 = Text(v)
		}
		p.Columns = append(p.Columns, _elem229)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *GetRowWithColumnsArgs) readField4(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s")
	}
	p.Attributes = make(map[Text]Text, size)
	for i := 0; i < size; i++ {
		var _key230 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_key230 = Text(v)
		}
		var _val231 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_val231 = Text(v)
		}
		p.Attributes[_key230] = _val231
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s")
	}
	return nil
}

func (p *GetRowWithColumnsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRowWithColumns_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowWithColumnsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.BINARY, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *GetRowWithColumnsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Row != nil {
		if err := oprot.WriteFieldBegin("row", thrift.BINARY, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Row); err != nil {
			return fmt.Errorf("%T.row (2) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:row: %s", p, err)
		}
	}
	return err
}

func (p *GetRowWithColumnsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Columns != nil {
		if err := oprot.WriteFieldBegin("columns", thrift.LIST, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:columns: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.BINARY, len(p.Columns)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Columns {
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:columns: %s", p, err)
		}
	}
	return err
}

func (p *GetRowWithColumnsArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if p.Attributes != nil {
		if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:attributes: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.BINARY, thrift.BINARY, len(p.Attributes)); err != nil {
			return fmt.Errorf("error writing map begin: %s")
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteBinary(k); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:attributes: %s", p, err)
		}
	}
	return err
}

func (p *GetRowWithColumnsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowWithColumnsArgs(%+v)", *p)
}

type GetRowWithColumnsResult struct {
	Success []*TRowResult `thrift:"success,0"`
	Io      *IOError      `thrift:"io,1"`
}

func NewGetRowWithColumnsResult() *GetRowWithColumnsResult {
	return &GetRowWithColumnsResult{}
}

func (p *GetRowWithColumnsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowWithColumnsResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]*TRowResult, 0, size)
	for i := 0; i < size; i++ {
		_elem232 := NewTRowResult()
		if err := _elem232.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem232)
		}
		p.Success = append(p.Success, _elem232)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *GetRowWithColumnsResult) readField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io)
	}
	return nil
}

func (p *GetRowWithColumnsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRowWithColumns_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowWithColumnsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetRowWithColumnsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetRowWithColumnsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowWithColumnsResult(%+v)", *p)
}

type GetRowTsArgs struct {
	TableName  Text          `thrift:"tableName,1"`
	Row        Text          `thrift:"row,2"`
	Timestamp  int64         `thrift:"timestamp,3"`
	Attributes map[Text]Text `thrift:"attributes,4"`
}

func NewGetRowTsArgs() *GetRowTsArgs {
	return &GetRowTsArgs{}
}

func (p *GetRowTsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowTsArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.TableName = Text(v)
	}
	return nil
}

func (p *GetRowTsArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Row = Text(v)
	}
	return nil
}

func (p *GetRowTsArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.Timestamp = v
	}
	return nil
}

func (p *GetRowTsArgs) readField4(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s")
	}
	p.Attributes = make(map[Text]Text, size)
	for i := 0; i < size; i++ {
		var _key233 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_key233 = Text(v)
		}
		var _val234 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_val234 = Text(v)
		}
		p.Attributes[_key233] = _val234
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s")
	}
	return nil
}

func (p *GetRowTsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRowTs_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowTsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.BINARY, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *GetRowTsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Row != nil {
		if err := oprot.WriteFieldBegin("row", thrift.BINARY, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Row); err != nil {
			return fmt.Errorf("%T.row (2) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:row: %s", p, err)
		}
	}
	return err
}

func (p *GetRowTsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("timestamp", thrift.I64, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:timestamp: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Timestamp)); err != nil {
		return fmt.Errorf("%T.timestamp (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:timestamp: %s", p, err)
	}
	return err
}

func (p *GetRowTsArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if p.Attributes != nil {
		if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:attributes: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.BINARY, thrift.BINARY, len(p.Attributes)); err != nil {
			return fmt.Errorf("error writing map begin: %s")
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteBinary(k); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:attributes: %s", p, err)
		}
	}
	return err
}

func (p *GetRowTsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowTsArgs(%+v)", *p)
}

type GetRowTsResult struct {
	Success []*TRowResult `thrift:"success,0"`
	Io      *IOError      `thrift:"io,1"`
}

func NewGetRowTsResult() *GetRowTsResult {
	return &GetRowTsResult{}
}

func (p *GetRowTsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowTsResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]*TRowResult, 0, size)
	for i := 0; i < size; i++ {
		_elem235 := NewTRowResult()
		if err := _elem235.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem235)
		}
		p.Success = append(p.Success, _elem235)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *GetRowTsResult) readField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io)
	}
	return nil
}

func (p *GetRowTsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRowTs_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowTsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetRowTsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetRowTsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowTsResult(%+v)", *p)
}

type GetRowWithColumnsTsArgs struct {
	TableName  Text          `thrift:"tableName,1"`
	Row        Text          `thrift:"row,2"`
	Columns    []Text        `thrift:"columns,3"`
	Timestamp  int64         `thrift:"timestamp,4"`
	Attributes map[Text]Text `thrift:"attributes,5"`
}

func NewGetRowWithColumnsTsArgs() *GetRowWithColumnsTsArgs {
	return &GetRowWithColumnsTsArgs{}
}

func (p *GetRowWithColumnsTsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.readField5(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowWithColumnsTsArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.TableName = Text(v)
	}
	return nil
}

func (p *GetRowWithColumnsTsArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Row = Text(v)
	}
	return nil
}

func (p *GetRowWithColumnsTsArgs) readField3(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Columns = make([]Text, 0, size)
	for i := 0; i < size; i++ {
		var _elem236 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_elem236 = Text(v)
		}
		p.Columns = append(p.Columns, _elem236)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *GetRowWithColumnsTsArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 4: %s")
	} else {
		p.Timestamp = v
	}
	return nil
}

func (p *GetRowWithColumnsTsArgs) readField5(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s")
	}
	p.Attributes = make(map[Text]Text, size)
	for i := 0; i < size; i++ {
		var _key237 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_key237 = Text(v)
		}
		var _val238 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_val238 = Text(v)
		}
		p.Attributes[_key237] = _val238
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s")
	}
	return nil
}

func (p *GetRowWithColumnsTsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRowWithColumnsTs_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowWithColumnsTsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.BINARY, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *GetRowWithColumnsTsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Row != nil {
		if err := oprot.WriteFieldBegin("row", thrift.BINARY, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Row); err != nil {
			return fmt.Errorf("%T.row (2) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:row: %s", p, err)
		}
	}
	return err
}

func (p *GetRowWithColumnsTsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Columns != nil {
		if err := oprot.WriteFieldBegin("columns", thrift.LIST, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:columns: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.BINARY, len(p.Columns)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Columns {
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:columns: %s", p, err)
		}
	}
	return err
}

func (p *GetRowWithColumnsTsArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("timestamp", thrift.I64, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:timestamp: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Timestamp)); err != nil {
		return fmt.Errorf("%T.timestamp (4) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:timestamp: %s", p, err)
	}
	return err
}

func (p *GetRowWithColumnsTsArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if p.Attributes != nil {
		if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 5); err != nil {
			return fmt.Errorf("%T write field begin error 5:attributes: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.BINARY, thrift.BINARY, len(p.Attributes)); err != nil {
			return fmt.Errorf("error writing map begin: %s")
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteBinary(k); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 5:attributes: %s", p, err)
		}
	}
	return err
}

func (p *GetRowWithColumnsTsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowWithColumnsTsArgs(%+v)", *p)
}

type GetRowWithColumnsTsResult struct {
	Success []*TRowResult `thrift:"success,0"`
	Io      *IOError      `thrift:"io,1"`
}

func NewGetRowWithColumnsTsResult() *GetRowWithColumnsTsResult {
	return &GetRowWithColumnsTsResult{}
}

func (p *GetRowWithColumnsTsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowWithColumnsTsResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]*TRowResult, 0, size)
	for i := 0; i < size; i++ {
		_elem239 := NewTRowResult()
		if err := _elem239.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem239)
		}
		p.Success = append(p.Success, _elem239)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *GetRowWithColumnsTsResult) readField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io)
	}
	return nil
}

func (p *GetRowWithColumnsTsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRowWithColumnsTs_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowWithColumnsTsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetRowWithColumnsTsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetRowWithColumnsTsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowWithColumnsTsResult(%+v)", *p)
}

type GetRowsArgs struct {
	TableName  Text          `thrift:"tableName,1"`
	Rows       []Text        `thrift:"rows,2"`
	Attributes map[Text]Text `thrift:"attributes,3"`
}

func NewGetRowsArgs() *GetRowsArgs {
	return &GetRowsArgs{}
}

func (p *GetRowsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowsArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.TableName = Text(v)
	}
	return nil
}

func (p *GetRowsArgs) readField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Rows = make([]Text, 0, size)
	for i := 0; i < size; i++ {
		var _elem240 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_elem240 = Text(v)
		}
		p.Rows = append(p.Rows, _elem240)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *GetRowsArgs) readField3(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s")
	}
	p.Attributes = make(map[Text]Text, size)
	for i := 0; i < size; i++ {
		var _key241 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_key241 = Text(v)
		}
		var _val242 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_val242 = Text(v)
		}
		p.Attributes[_key241] = _val242
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s")
	}
	return nil
}

func (p *GetRowsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRows_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.BINARY, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *GetRowsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Rows != nil {
		if err := oprot.WriteFieldBegin("rows", thrift.LIST, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:rows: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.BINARY, len(p.Rows)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Rows {
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:rows: %s", p, err)
		}
	}
	return err
}

func (p *GetRowsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Attributes != nil {
		if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:attributes: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.BINARY, thrift.BINARY, len(p.Attributes)); err != nil {
			return fmt.Errorf("error writing map begin: %s")
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteBinary(k); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:attributes: %s", p, err)
		}
	}
	return err
}

func (p *GetRowsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowsArgs(%+v)", *p)
}

type GetRowsResult struct {
	Success []*TRowResult `thrift:"success,0"`
	Io      *IOError      `thrift:"io,1"`
}

func NewGetRowsResult() *GetRowsResult {
	return &GetRowsResult{}
}

func (p *GetRowsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowsResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]*TRowResult, 0, size)
	for i := 0; i < size; i++ {
		_elem243 := NewTRowResult()
		if err := _elem243.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem243)
		}
		p.Success = append(p.Success, _elem243)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *GetRowsResult) readField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io)
	}
	return nil
}

func (p *GetRowsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRows_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetRowsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetRowsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowsResult(%+v)", *p)
}

type GetRowsWithColumnsArgs struct {
	TableName  Text          `thrift:"tableName,1"`
	Rows       []Text        `thrift:"rows,2"`
	Columns    []Text        `thrift:"columns,3"`
	Attributes map[Text]Text `thrift:"attributes,4"`
}

func NewGetRowsWithColumnsArgs() *GetRowsWithColumnsArgs {
	return &GetRowsWithColumnsArgs{}
}

func (p *GetRowsWithColumnsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowsWithColumnsArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.TableName = Text(v)
	}
	return nil
}

func (p *GetRowsWithColumnsArgs) readField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Rows = make([]Text, 0, size)
	for i := 0; i < size; i++ {
		var _elem244 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_elem244 = Text(v)
		}
		p.Rows = append(p.Rows, _elem244)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *GetRowsWithColumnsArgs) readField3(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Columns = make([]Text, 0, size)
	for i := 0; i < size; i++ {
		var _elem245 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_elem245 = Text(v)
		}
		p.Columns = append(p.Columns, _elem245)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *GetRowsWithColumnsArgs) readField4(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s")
	}
	p.Attributes = make(map[Text]Text, size)
	for i := 0; i < size; i++ {
		var _key246 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_key246 = Text(v)
		}
		var _val247 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_val247 = Text(v)
		}
		p.Attributes[_key246] = _val247
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s")
	}
	return nil
}

func (p *GetRowsWithColumnsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRowsWithColumns_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowsWithColumnsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.BINARY, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *GetRowsWithColumnsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Rows != nil {
		if err := oprot.WriteFieldBegin("rows", thrift.LIST, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:rows: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.BINARY, len(p.Rows)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Rows {
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:rows: %s", p, err)
		}
	}
	return err
}

func (p *GetRowsWithColumnsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Columns != nil {
		if err := oprot.WriteFieldBegin("columns", thrift.LIST, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:columns: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.BINARY, len(p.Columns)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Columns {
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:columns: %s", p, err)
		}
	}
	return err
}

func (p *GetRowsWithColumnsArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if p.Attributes != nil {
		if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:attributes: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.BINARY, thrift.BINARY, len(p.Attributes)); err != nil {
			return fmt.Errorf("error writing map begin: %s")
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteBinary(k); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:attributes: %s", p, err)
		}
	}
	return err
}

func (p *GetRowsWithColumnsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowsWithColumnsArgs(%+v)", *p)
}

type GetRowsWithColumnsResult struct {
	Success []*TRowResult `thrift:"success,0"`
	Io      *IOError      `thrift:"io,1"`
}

func NewGetRowsWithColumnsResult() *GetRowsWithColumnsResult {
	return &GetRowsWithColumnsResult{}
}

func (p *GetRowsWithColumnsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowsWithColumnsResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]*TRowResult, 0, size)
	for i := 0; i < size; i++ {
		_elem248 := NewTRowResult()
		if err := _elem248.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem248)
		}
		p.Success = append(p.Success, _elem248)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *GetRowsWithColumnsResult) readField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io)
	}
	return nil
}

func (p *GetRowsWithColumnsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRowsWithColumns_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowsWithColumnsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetRowsWithColumnsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetRowsWithColumnsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowsWithColumnsResult(%+v)", *p)
}

type GetRowsTsArgs struct {
	TableName  Text          `thrift:"tableName,1"`
	Rows       []Text        `thrift:"rows,2"`
	Timestamp  int64         `thrift:"timestamp,3"`
	Attributes map[Text]Text `thrift:"attributes,4"`
}

func NewGetRowsTsArgs() *GetRowsTsArgs {
	return &GetRowsTsArgs{}
}

func (p *GetRowsTsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowsTsArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.TableName = Text(v)
	}
	return nil
}

func (p *GetRowsTsArgs) readField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Rows = make([]Text, 0, size)
	for i := 0; i < size; i++ {
		var _elem249 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_elem249 = Text(v)
		}
		p.Rows = append(p.Rows, _elem249)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *GetRowsTsArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.Timestamp = v
	}
	return nil
}

func (p *GetRowsTsArgs) readField4(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s")
	}
	p.Attributes = make(map[Text]Text, size)
	for i := 0; i < size; i++ {
		var _key250 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_key250 = Text(v)
		}
		var _val251 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_val251 = Text(v)
		}
		p.Attributes[_key250] = _val251
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s")
	}
	return nil
}

func (p *GetRowsTsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRowsTs_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowsTsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.BINARY, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *GetRowsTsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Rows != nil {
		if err := oprot.WriteFieldBegin("rows", thrift.LIST, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:rows: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.BINARY, len(p.Rows)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Rows {
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:rows: %s", p, err)
		}
	}
	return err
}

func (p *GetRowsTsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("timestamp", thrift.I64, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:timestamp: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Timestamp)); err != nil {
		return fmt.Errorf("%T.timestamp (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:timestamp: %s", p, err)
	}
	return err
}

func (p *GetRowsTsArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if p.Attributes != nil {
		if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:attributes: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.BINARY, thrift.BINARY, len(p.Attributes)); err != nil {
			return fmt.Errorf("error writing map begin: %s")
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteBinary(k); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:attributes: %s", p, err)
		}
	}
	return err
}

func (p *GetRowsTsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowsTsArgs(%+v)", *p)
}

type GetRowsTsResult struct {
	Success []*TRowResult `thrift:"success,0"`
	Io      *IOError      `thrift:"io,1"`
}

func NewGetRowsTsResult() *GetRowsTsResult {
	return &GetRowsTsResult{}
}

func (p *GetRowsTsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowsTsResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]*TRowResult, 0, size)
	for i := 0; i < size; i++ {
		_elem252 := NewTRowResult()
		if err := _elem252.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem252)
		}
		p.Success = append(p.Success, _elem252)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *GetRowsTsResult) readField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io)
	}
	return nil
}

func (p *GetRowsTsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRowsTs_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowsTsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetRowsTsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetRowsTsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowsTsResult(%+v)", *p)
}

type GetRowsWithColumnsTsArgs struct {
	TableName  Text          `thrift:"tableName,1"`
	Rows       []Text        `thrift:"rows,2"`
	Columns    []Text        `thrift:"columns,3"`
	Timestamp  int64         `thrift:"timestamp,4"`
	Attributes map[Text]Text `thrift:"attributes,5"`
}

func NewGetRowsWithColumnsTsArgs() *GetRowsWithColumnsTsArgs {
	return &GetRowsWithColumnsTsArgs{}
}

func (p *GetRowsWithColumnsTsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.readField5(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowsWithColumnsTsArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.TableName = Text(v)
	}
	return nil
}

func (p *GetRowsWithColumnsTsArgs) readField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Rows = make([]Text, 0, size)
	for i := 0; i < size; i++ {
		var _elem253 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_elem253 = Text(v)
		}
		p.Rows = append(p.Rows, _elem253)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *GetRowsWithColumnsTsArgs) readField3(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Columns = make([]Text, 0, size)
	for i := 0; i < size; i++ {
		var _elem254 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_elem254 = Text(v)
		}
		p.Columns = append(p.Columns, _elem254)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *GetRowsWithColumnsTsArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 4: %s")
	} else {
		p.Timestamp = v
	}
	return nil
}

func (p *GetRowsWithColumnsTsArgs) readField5(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s")
	}
	p.Attributes = make(map[Text]Text, size)
	for i := 0; i < size; i++ {
		var _key255 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_key255 = Text(v)
		}
		var _val256 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_val256 = Text(v)
		}
		p.Attributes[_key255] = _val256
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s")
	}
	return nil
}

func (p *GetRowsWithColumnsTsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRowsWithColumnsTs_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowsWithColumnsTsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.BINARY, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *GetRowsWithColumnsTsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Rows != nil {
		if err := oprot.WriteFieldBegin("rows", thrift.LIST, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:rows: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.BINARY, len(p.Rows)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Rows {
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:rows: %s", p, err)
		}
	}
	return err
}

func (p *GetRowsWithColumnsTsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Columns != nil {
		if err := oprot.WriteFieldBegin("columns", thrift.LIST, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:columns: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.BINARY, len(p.Columns)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Columns {
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:columns: %s", p, err)
		}
	}
	return err
}

func (p *GetRowsWithColumnsTsArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("timestamp", thrift.I64, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:timestamp: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Timestamp)); err != nil {
		return fmt.Errorf("%T.timestamp (4) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:timestamp: %s", p, err)
	}
	return err
}

func (p *GetRowsWithColumnsTsArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if p.Attributes != nil {
		if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 5); err != nil {
			return fmt.Errorf("%T write field begin error 5:attributes: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.BINARY, thrift.BINARY, len(p.Attributes)); err != nil {
			return fmt.Errorf("error writing map begin: %s")
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteBinary(k); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 5:attributes: %s", p, err)
		}
	}
	return err
}

func (p *GetRowsWithColumnsTsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowsWithColumnsTsArgs(%+v)", *p)
}

type GetRowsWithColumnsTsResult struct {
	Success []*TRowResult `thrift:"success,0"`
	Io      *IOError      `thrift:"io,1"`
}

func NewGetRowsWithColumnsTsResult() *GetRowsWithColumnsTsResult {
	return &GetRowsWithColumnsTsResult{}
}

func (p *GetRowsWithColumnsTsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowsWithColumnsTsResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]*TRowResult, 0, size)
	for i := 0; i < size; i++ {
		_elem257 := NewTRowResult()
		if err := _elem257.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem257)
		}
		p.Success = append(p.Success, _elem257)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *GetRowsWithColumnsTsResult) readField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io)
	}
	return nil
}

func (p *GetRowsWithColumnsTsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRowsWithColumnsTs_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowsWithColumnsTsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetRowsWithColumnsTsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetRowsWithColumnsTsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowsWithColumnsTsResult(%+v)", *p)
}

type MutateRowArgs struct {
	TableName  Text          `thrift:"tableName,1"`
	Row        Text          `thrift:"row,2"`
	Mutations  []*Mutation   `thrift:"mutations,3"`
	Attributes map[Text]Text `thrift:"attributes,4"`
}

func NewMutateRowArgs() *MutateRowArgs {
	return &MutateRowArgs{}
}

func (p *MutateRowArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MutateRowArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.TableName = Text(v)
	}
	return nil
}

func (p *MutateRowArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Row = Text(v)
	}
	return nil
}

func (p *MutateRowArgs) readField3(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Mutations = make([]*Mutation, 0, size)
	for i := 0; i < size; i++ {
		_elem258 := NewMutation()
		if err := _elem258.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem258)
		}
		p.Mutations = append(p.Mutations, _elem258)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *MutateRowArgs) readField4(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s")
	}
	p.Attributes = make(map[Text]Text, size)
	for i := 0; i < size; i++ {
		var _key259 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_key259 = Text(v)
		}
		var _val260 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_val260 = Text(v)
		}
		p.Attributes[_key259] = _val260
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s")
	}
	return nil
}

func (p *MutateRowArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("mutateRow_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *MutateRowArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.BINARY, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Row != nil {
		if err := oprot.WriteFieldBegin("row", thrift.BINARY, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Row); err != nil {
			return fmt.Errorf("%T.row (2) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:row: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Mutations != nil {
		if err := oprot.WriteFieldBegin("mutations", thrift.LIST, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:mutations: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Mutations)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Mutations {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:mutations: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if p.Attributes != nil {
		if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:attributes: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.BINARY, thrift.BINARY, len(p.Attributes)); err != nil {
			return fmt.Errorf("error writing map begin: %s")
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteBinary(k); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:attributes: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MutateRowArgs(%+v)", *p)
}

type MutateRowResult struct {
	Io *IOError         `thrift:"io,1"`
	Ia *IllegalArgument `thrift:"ia,2"`
}

func NewMutateRowResult() *MutateRowResult {
	return &MutateRowResult{}
}

func (p *MutateRowResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MutateRowResult) readField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io)
	}
	return nil
}

func (p *MutateRowResult) readField2(iprot thrift.TProtocol) error {
	p.Ia = NewIllegalArgument()
	if err := p.Ia.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ia)
	}
	return nil
}

func (p *MutateRowResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("mutateRow_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Ia != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *MutateRowResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ia != nil {
		if err := oprot.WriteFieldBegin("ia", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ia: %s", p, err)
		}
		if err := p.Ia.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ia)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ia: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MutateRowResult(%+v)", *p)
}

type MutateRowTsArgs struct {
	TableName  Text          `thrift:"tableName,1"`
	Row        Text          `thrift:"row,2"`
	Mutations  []*Mutation   `thrift:"mutations,3"`
	Timestamp  int64         `thrift:"timestamp,4"`
	Attributes map[Text]Text `thrift:"attributes,5"`
}

func NewMutateRowTsArgs() *MutateRowTsArgs {
	return &MutateRowTsArgs{}
}

func (p *MutateRowTsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.readField5(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MutateRowTsArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.TableName = Text(v)
	}
	return nil
}

func (p *MutateRowTsArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Row = Text(v)
	}
	return nil
}

func (p *MutateRowTsArgs) readField3(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Mutations = make([]*Mutation, 0, size)
	for i := 0; i < size; i++ {
		_elem261 := NewMutation()
		if err := _elem261.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem261)
		}
		p.Mutations = append(p.Mutations, _elem261)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *MutateRowTsArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 4: %s")
	} else {
		p.Timestamp = v
	}
	return nil
}

func (p *MutateRowTsArgs) readField5(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s")
	}
	p.Attributes = make(map[Text]Text, size)
	for i := 0; i < size; i++ {
		var _key262 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_key262 = Text(v)
		}
		var _val263 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_val263 = Text(v)
		}
		p.Attributes[_key262] = _val263
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s")
	}
	return nil
}

func (p *MutateRowTsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("mutateRowTs_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *MutateRowTsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.BINARY, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowTsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Row != nil {
		if err := oprot.WriteFieldBegin("row", thrift.BINARY, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Row); err != nil {
			return fmt.Errorf("%T.row (2) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:row: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowTsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Mutations != nil {
		if err := oprot.WriteFieldBegin("mutations", thrift.LIST, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:mutations: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Mutations)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Mutations {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:mutations: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowTsArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("timestamp", thrift.I64, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:timestamp: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Timestamp)); err != nil {
		return fmt.Errorf("%T.timestamp (4) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:timestamp: %s", p, err)
	}
	return err
}

func (p *MutateRowTsArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if p.Attributes != nil {
		if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 5); err != nil {
			return fmt.Errorf("%T write field begin error 5:attributes: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.BINARY, thrift.BINARY, len(p.Attributes)); err != nil {
			return fmt.Errorf("error writing map begin: %s")
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteBinary(k); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 5:attributes: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowTsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MutateRowTsArgs(%+v)", *p)
}

type MutateRowTsResult struct {
	Io *IOError         `thrift:"io,1"`
	Ia *IllegalArgument `thrift:"ia,2"`
}

func NewMutateRowTsResult() *MutateRowTsResult {
	return &MutateRowTsResult{}
}

func (p *MutateRowTsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MutateRowTsResult) readField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io)
	}
	return nil
}

func (p *MutateRowTsResult) readField2(iprot thrift.TProtocol) error {
	p.Ia = NewIllegalArgument()
	if err := p.Ia.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ia)
	}
	return nil
}

func (p *MutateRowTsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("mutateRowTs_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Ia != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *MutateRowTsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowTsResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ia != nil {
		if err := oprot.WriteFieldBegin("ia", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ia: %s", p, err)
		}
		if err := p.Ia.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ia)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ia: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowTsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MutateRowTsResult(%+v)", *p)
}

type MutateRowsArgs struct {
	TableName  Text             `thrift:"tableName,1"`
	RowBatches []*BatchMutation `thrift:"rowBatches,2"`
	Attributes map[Text]Text    `thrift:"attributes,3"`
}

func NewMutateRowsArgs() *MutateRowsArgs {
	return &MutateRowsArgs{}
}

func (p *MutateRowsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MutateRowsArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.TableName = Text(v)
	}
	return nil
}

func (p *MutateRowsArgs) readField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.RowBatches = make([]*BatchMutation, 0, size)
	for i := 0; i < size; i++ {
		_elem264 := NewBatchMutation()
		if err := _elem264.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem264)
		}
		p.RowBatches = append(p.RowBatches, _elem264)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *MutateRowsArgs) readField3(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s")
	}
	p.Attributes = make(map[Text]Text, size)
	for i := 0; i < size; i++ {
		var _key265 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_key265 = Text(v)
		}
		var _val266 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_val266 = Text(v)
		}
		p.Attributes[_key265] = _val266
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s")
	}
	return nil
}

func (p *MutateRowsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("mutateRows_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *MutateRowsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.BINARY, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.RowBatches != nil {
		if err := oprot.WriteFieldBegin("rowBatches", thrift.LIST, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:rowBatches: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.RowBatches)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.RowBatches {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:rowBatches: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Attributes != nil {
		if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:attributes: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.BINARY, thrift.BINARY, len(p.Attributes)); err != nil {
			return fmt.Errorf("error writing map begin: %s")
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteBinary(k); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:attributes: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MutateRowsArgs(%+v)", *p)
}

type MutateRowsResult struct {
	Io *IOError         `thrift:"io,1"`
	Ia *IllegalArgument `thrift:"ia,2"`
}

func NewMutateRowsResult() *MutateRowsResult {
	return &MutateRowsResult{}
}

func (p *MutateRowsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MutateRowsResult) readField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io)
	}
	return nil
}

func (p *MutateRowsResult) readField2(iprot thrift.TProtocol) error {
	p.Ia = NewIllegalArgument()
	if err := p.Ia.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ia)
	}
	return nil
}

func (p *MutateRowsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("mutateRows_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Ia != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *MutateRowsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowsResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ia != nil {
		if err := oprot.WriteFieldBegin("ia", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ia: %s", p, err)
		}
		if err := p.Ia.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ia)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ia: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MutateRowsResult(%+v)", *p)
}

type MutateRowsTsArgs struct {
	TableName  Text             `thrift:"tableName,1"`
	RowBatches []*BatchMutation `thrift:"rowBatches,2"`
	Timestamp  int64            `thrift:"timestamp,3"`
	Attributes map[Text]Text    `thrift:"attributes,4"`
}

func NewMutateRowsTsArgs() *MutateRowsTsArgs {
	return &MutateRowsTsArgs{}
}

func (p *MutateRowsTsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MutateRowsTsArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.TableName = Text(v)
	}
	return nil
}

func (p *MutateRowsTsArgs) readField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.RowBatches = make([]*BatchMutation, 0, size)
	for i := 0; i < size; i++ {
		_elem267 := NewBatchMutation()
		if err := _elem267.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem267)
		}
		p.RowBatches = append(p.RowBatches, _elem267)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *MutateRowsTsArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.Timestamp = v
	}
	return nil
}

func (p *MutateRowsTsArgs) readField4(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s")
	}
	p.Attributes = make(map[Text]Text, size)
	for i := 0; i < size; i++ {
		var _key268 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_key268 = Text(v)
		}
		var _val269 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_val269 = Text(v)
		}
		p.Attributes[_key268] = _val269
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s")
	}
	return nil
}

func (p *MutateRowsTsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("mutateRowsTs_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *MutateRowsTsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.BINARY, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowsTsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.RowBatches != nil {
		if err := oprot.WriteFieldBegin("rowBatches", thrift.LIST, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:rowBatches: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.RowBatches)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.RowBatches {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:rowBatches: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowsTsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("timestamp", thrift.I64, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:timestamp: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Timestamp)); err != nil {
		return fmt.Errorf("%T.timestamp (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:timestamp: %s", p, err)
	}
	return err
}

func (p *MutateRowsTsArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if p.Attributes != nil {
		if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:attributes: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.BINARY, thrift.BINARY, len(p.Attributes)); err != nil {
			return fmt.Errorf("error writing map begin: %s")
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteBinary(k); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:attributes: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowsTsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MutateRowsTsArgs(%+v)", *p)
}

type MutateRowsTsResult struct {
	Io *IOError         `thrift:"io,1"`
	Ia *IllegalArgument `thrift:"ia,2"`
}

func NewMutateRowsTsResult() *MutateRowsTsResult {
	return &MutateRowsTsResult{}
}

func (p *MutateRowsTsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MutateRowsTsResult) readField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io)
	}
	return nil
}

func (p *MutateRowsTsResult) readField2(iprot thrift.TProtocol) error {
	p.Ia = NewIllegalArgument()
	if err := p.Ia.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ia)
	}
	return nil
}

func (p *MutateRowsTsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("mutateRowsTs_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Ia != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *MutateRowsTsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowsTsResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ia != nil {
		if err := oprot.WriteFieldBegin("ia", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ia: %s", p, err)
		}
		if err := p.Ia.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ia)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ia: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowsTsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MutateRowsTsResult(%+v)", *p)
}

type AtomicIncrementArgs struct {
	TableName Text  `thrift:"tableName,1"`
	Row       Text  `thrift:"row,2"`
	Column    Text  `thrift:"column,3"`
	Value     int64 `thrift:"value,4"`
}

func NewAtomicIncrementArgs() *AtomicIncrementArgs {
	return &AtomicIncrementArgs{}
}

func (p *AtomicIncrementArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AtomicIncrementArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.TableName = Text(v)
	}
	return nil
}

func (p *AtomicIncrementArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Row = Text(v)
	}
	return nil
}

func (p *AtomicIncrementArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.Column = Text(v)
	}
	return nil
}

func (p *AtomicIncrementArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 4: %s")
	} else {
		p.Value = v
	}
	return nil
}

func (p *AtomicIncrementArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("atomicIncrement_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *AtomicIncrementArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.BINARY, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *AtomicIncrementArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Row != nil {
		if err := oprot.WriteFieldBegin("row", thrift.BINARY, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Row); err != nil {
			return fmt.Errorf("%T.row (2) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:row: %s", p, err)
		}
	}
	return err
}

func (p *AtomicIncrementArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Column != nil {
		if err := oprot.WriteFieldBegin("column", thrift.BINARY, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:column: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Column); err != nil {
			return fmt.Errorf("%T.column (3) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:column: %s", p, err)
		}
	}
	return err
}

func (p *AtomicIncrementArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("value", thrift.I64, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:value: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Value)); err != nil {
		return fmt.Errorf("%T.value (4) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:value: %s", p, err)
	}
	return err
}

func (p *AtomicIncrementArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AtomicIncrementArgs(%+v)", *p)
}

type AtomicIncrementResult struct {
	Success int64            `thrift:"success,0"`
	Io      *IOError         `thrift:"io,1"`
	Ia      *IllegalArgument `thrift:"ia,2"`
}

func NewAtomicIncrementResult() *AtomicIncrementResult {
	return &AtomicIncrementResult{}
}

func (p *AtomicIncrementResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AtomicIncrementResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *AtomicIncrementResult) readField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io)
	}
	return nil
}

func (p *AtomicIncrementResult) readField2(iprot thrift.TProtocol) error {
	p.Ia = NewIllegalArgument()
	if err := p.Ia.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ia)
	}
	return nil
}

func (p *AtomicIncrementResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("atomicIncrement_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Ia != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *AtomicIncrementResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.I64, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *AtomicIncrementResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *AtomicIncrementResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ia != nil {
		if err := oprot.WriteFieldBegin("ia", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ia: %s", p, err)
		}
		if err := p.Ia.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ia)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ia: %s", p, err)
		}
	}
	return err
}

func (p *AtomicIncrementResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AtomicIncrementResult(%+v)", *p)
}

type DeleteAllArgs struct {
	TableName  Text          `thrift:"tableName,1"`
	Row        Text          `thrift:"row,2"`
	Column     Text          `thrift:"column,3"`
	Attributes map[Text]Text `thrift:"attributes,4"`
}

func NewDeleteAllArgs() *DeleteAllArgs {
	return &DeleteAllArgs{}
}

func (p *DeleteAllArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteAllArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.TableName = Text(v)
	}
	return nil
}

func (p *DeleteAllArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Row = Text(v)
	}
	return nil
}

func (p *DeleteAllArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.Column = Text(v)
	}
	return nil
}

func (p *DeleteAllArgs) readField4(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s")
	}
	p.Attributes = make(map[Text]Text, size)
	for i := 0; i < size; i++ {
		var _key270 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_key270 = Text(v)
		}
		var _val271 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_val271 = Text(v)
		}
		p.Attributes[_key270] = _val271
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s")
	}
	return nil
}

func (p *DeleteAllArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteAll_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteAllArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.BINARY, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *DeleteAllArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Row != nil {
		if err := oprot.WriteFieldBegin("row", thrift.BINARY, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Row); err != nil {
			return fmt.Errorf("%T.row (2) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:row: %s", p, err)
		}
	}
	return err
}

func (p *DeleteAllArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Column != nil {
		if err := oprot.WriteFieldBegin("column", thrift.BINARY, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:column: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Column); err != nil {
			return fmt.Errorf("%T.column (3) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:column: %s", p, err)
		}
	}
	return err
}

func (p *DeleteAllArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if p.Attributes != nil {
		if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:attributes: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.BINARY, thrift.BINARY, len(p.Attributes)); err != nil {
			return fmt.Errorf("error writing map begin: %s")
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteBinary(k); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:attributes: %s", p, err)
		}
	}
	return err
}

func (p *DeleteAllArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteAllArgs(%+v)", *p)
}

type DeleteAllResult struct {
	Io *IOError `thrift:"io,1"`
}

func NewDeleteAllResult() *DeleteAllResult {
	return &DeleteAllResult{}
}

func (p *DeleteAllResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteAllResult) readField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io)
	}
	return nil
}

func (p *DeleteAllResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteAll_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteAllResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *DeleteAllResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteAllResult(%+v)", *p)
}

type DeleteAllTsArgs struct {
	TableName  Text          `thrift:"tableName,1"`
	Row        Text          `thrift:"row,2"`
	Column     Text          `thrift:"column,3"`
	Timestamp  int64         `thrift:"timestamp,4"`
	Attributes map[Text]Text `thrift:"attributes,5"`
}

func NewDeleteAllTsArgs() *DeleteAllTsArgs {
	return &DeleteAllTsArgs{}
}

func (p *DeleteAllTsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.readField5(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteAllTsArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.TableName = Text(v)
	}
	return nil
}

func (p *DeleteAllTsArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Row = Text(v)
	}
	return nil
}

func (p *DeleteAllTsArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.Column = Text(v)
	}
	return nil
}

func (p *DeleteAllTsArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 4: %s")
	} else {
		p.Timestamp = v
	}
	return nil
}

func (p *DeleteAllTsArgs) readField5(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s")
	}
	p.Attributes = make(map[Text]Text, size)
	for i := 0; i < size; i++ {
		var _key272 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_key272 = Text(v)
		}
		var _val273 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_val273 = Text(v)
		}
		p.Attributes[_key272] = _val273
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s")
	}
	return nil
}

func (p *DeleteAllTsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteAllTs_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteAllTsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.BINARY, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *DeleteAllTsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Row != nil {
		if err := oprot.WriteFieldBegin("row", thrift.BINARY, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Row); err != nil {
			return fmt.Errorf("%T.row (2) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:row: %s", p, err)
		}
	}
	return err
}

func (p *DeleteAllTsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Column != nil {
		if err := oprot.WriteFieldBegin("column", thrift.BINARY, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:column: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Column); err != nil {
			return fmt.Errorf("%T.column (3) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:column: %s", p, err)
		}
	}
	return err
}

func (p *DeleteAllTsArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("timestamp", thrift.I64, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:timestamp: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Timestamp)); err != nil {
		return fmt.Errorf("%T.timestamp (4) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:timestamp: %s", p, err)
	}
	return err
}

func (p *DeleteAllTsArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if p.Attributes != nil {
		if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 5); err != nil {
			return fmt.Errorf("%T write field begin error 5:attributes: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.BINARY, thrift.BINARY, len(p.Attributes)); err != nil {
			return fmt.Errorf("error writing map begin: %s")
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteBinary(k); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 5:attributes: %s", p, err)
		}
	}
	return err
}

func (p *DeleteAllTsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteAllTsArgs(%+v)", *p)
}

type DeleteAllTsResult struct {
	Io *IOError `thrift:"io,1"`
}

func NewDeleteAllTsResult() *DeleteAllTsResult {
	return &DeleteAllTsResult{}
}

func (p *DeleteAllTsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteAllTsResult) readField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io)
	}
	return nil
}

func (p *DeleteAllTsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteAllTs_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteAllTsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *DeleteAllTsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteAllTsResult(%+v)", *p)
}

type DeleteAllRowArgs struct {
	TableName  Text          `thrift:"tableName,1"`
	Row        Text          `thrift:"row,2"`
	Attributes map[Text]Text `thrift:"attributes,3"`
}

func NewDeleteAllRowArgs() *DeleteAllRowArgs {
	return &DeleteAllRowArgs{}
}

func (p *DeleteAllRowArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteAllRowArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.TableName = Text(v)
	}
	return nil
}

func (p *DeleteAllRowArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Row = Text(v)
	}
	return nil
}

func (p *DeleteAllRowArgs) readField3(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s")
	}
	p.Attributes = make(map[Text]Text, size)
	for i := 0; i < size; i++ {
		var _key274 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_key274 = Text(v)
		}
		var _val275 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_val275 = Text(v)
		}
		p.Attributes[_key274] = _val275
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s")
	}
	return nil
}

func (p *DeleteAllRowArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteAllRow_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteAllRowArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.BINARY, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *DeleteAllRowArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Row != nil {
		if err := oprot.WriteFieldBegin("row", thrift.BINARY, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Row); err != nil {
			return fmt.Errorf("%T.row (2) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:row: %s", p, err)
		}
	}
	return err
}

func (p *DeleteAllRowArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Attributes != nil {
		if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:attributes: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.BINARY, thrift.BINARY, len(p.Attributes)); err != nil {
			return fmt.Errorf("error writing map begin: %s")
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteBinary(k); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:attributes: %s", p, err)
		}
	}
	return err
}

func (p *DeleteAllRowArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteAllRowArgs(%+v)", *p)
}

type DeleteAllRowResult struct {
	Io *IOError `thrift:"io,1"`
}

func NewDeleteAllRowResult() *DeleteAllRowResult {
	return &DeleteAllRowResult{}
}

func (p *DeleteAllRowResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteAllRowResult) readField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io)
	}
	return nil
}

func (p *DeleteAllRowResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteAllRow_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteAllRowResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *DeleteAllRowResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteAllRowResult(%+v)", *p)
}

type IncrementArgs struct {
	Increment *TIncrement `thrift:"increment,1"`
}

func NewIncrementArgs() *IncrementArgs {
	return &IncrementArgs{}
}

func (p *IncrementArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *IncrementArgs) readField1(iprot thrift.TProtocol) error {
	p.Increment = NewTIncrement()
	if err := p.Increment.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Increment)
	}
	return nil
}

func (p *IncrementArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("increment_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *IncrementArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Increment != nil {
		if err := oprot.WriteFieldBegin("increment", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:increment: %s", p, err)
		}
		if err := p.Increment.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Increment)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:increment: %s", p, err)
		}
	}
	return err
}

func (p *IncrementArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("IncrementArgs(%+v)", *p)
}

type IncrementResult struct {
	Io *IOError `thrift:"io,1"`
}

func NewIncrementResult() *IncrementResult {
	return &IncrementResult{}
}

func (p *IncrementResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *IncrementResult) readField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io)
	}
	return nil
}

func (p *IncrementResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("increment_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *IncrementResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *IncrementResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("IncrementResult(%+v)", *p)
}

type IncrementRowsArgs struct {
	Increments []*TIncrement `thrift:"increments,1"`
}

func NewIncrementRowsArgs() *IncrementRowsArgs {
	return &IncrementRowsArgs{}
}

func (p *IncrementRowsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *IncrementRowsArgs) readField1(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Increments = make([]*TIncrement, 0, size)
	for i := 0; i < size; i++ {
		_elem276 := NewTIncrement()
		if err := _elem276.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem276)
		}
		p.Increments = append(p.Increments, _elem276)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *IncrementRowsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("incrementRows_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *IncrementRowsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Increments != nil {
		if err := oprot.WriteFieldBegin("increments", thrift.LIST, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:increments: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Increments)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Increments {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:increments: %s", p, err)
		}
	}
	return err
}

func (p *IncrementRowsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("IncrementRowsArgs(%+v)", *p)
}

type IncrementRowsResult struct {
	Io *IOError `thrift:"io,1"`
}

func NewIncrementRowsResult() *IncrementRowsResult {
	return &IncrementRowsResult{}
}

func (p *IncrementRowsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *IncrementRowsResult) readField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io)
	}
	return nil
}

func (p *IncrementRowsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("incrementRows_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *IncrementRowsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *IncrementRowsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("IncrementRowsResult(%+v)", *p)
}

type DeleteAllRowTsArgs struct {
	TableName  Text          `thrift:"tableName,1"`
	Row        Text          `thrift:"row,2"`
	Timestamp  int64         `thrift:"timestamp,3"`
	Attributes map[Text]Text `thrift:"attributes,4"`
}

func NewDeleteAllRowTsArgs() *DeleteAllRowTsArgs {
	return &DeleteAllRowTsArgs{}
}

func (p *DeleteAllRowTsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteAllRowTsArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.TableName = Text(v)
	}
	return nil
}

func (p *DeleteAllRowTsArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Row = Text(v)
	}
	return nil
}

func (p *DeleteAllRowTsArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.Timestamp = v
	}
	return nil
}

func (p *DeleteAllRowTsArgs) readField4(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s")
	}
	p.Attributes = make(map[Text]Text, size)
	for i := 0; i < size; i++ {
		var _key277 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_key277 = Text(v)
		}
		var _val278 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_val278 = Text(v)
		}
		p.Attributes[_key277] = _val278
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s")
	}
	return nil
}

func (p *DeleteAllRowTsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteAllRowTs_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteAllRowTsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.BINARY, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *DeleteAllRowTsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Row != nil {
		if err := oprot.WriteFieldBegin("row", thrift.BINARY, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Row); err != nil {
			return fmt.Errorf("%T.row (2) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:row: %s", p, err)
		}
	}
	return err
}

func (p *DeleteAllRowTsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("timestamp", thrift.I64, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:timestamp: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Timestamp)); err != nil {
		return fmt.Errorf("%T.timestamp (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:timestamp: %s", p, err)
	}
	return err
}

func (p *DeleteAllRowTsArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if p.Attributes != nil {
		if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:attributes: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.BINARY, thrift.BINARY, len(p.Attributes)); err != nil {
			return fmt.Errorf("error writing map begin: %s")
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteBinary(k); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:attributes: %s", p, err)
		}
	}
	return err
}

func (p *DeleteAllRowTsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteAllRowTsArgs(%+v)", *p)
}

type DeleteAllRowTsResult struct {
	Io *IOError `thrift:"io,1"`
}

func NewDeleteAllRowTsResult() *DeleteAllRowTsResult {
	return &DeleteAllRowTsResult{}
}

func (p *DeleteAllRowTsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteAllRowTsResult) readField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io)
	}
	return nil
}

func (p *DeleteAllRowTsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteAllRowTs_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteAllRowTsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *DeleteAllRowTsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteAllRowTsResult(%+v)", *p)
}

type ScannerOpenWithScanArgs struct {
	TableName  Text          `thrift:"tableName,1"`
	Scan       *TScan        `thrift:"scan,2"`
	Attributes map[Text]Text `thrift:"attributes,3"`
}

func NewScannerOpenWithScanArgs() *ScannerOpenWithScanArgs {
	return &ScannerOpenWithScanArgs{}
}

func (p *ScannerOpenWithScanArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerOpenWithScanArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.TableName = Text(v)
	}
	return nil
}

func (p *ScannerOpenWithScanArgs) readField2(iprot thrift.TProtocol) error {
	p.Scan = NewTScan()
	if err := p.Scan.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Scan)
	}
	return nil
}

func (p *ScannerOpenWithScanArgs) readField3(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s")
	}
	p.Attributes = make(map[Text]Text, size)
	for i := 0; i < size; i++ {
		var _key279 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_key279 = Text(v)
		}
		var _val280 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_val280 = Text(v)
		}
		p.Attributes[_key279] = _val280
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s")
	}
	return nil
}

func (p *ScannerOpenWithScanArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scannerOpenWithScan_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerOpenWithScanArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.BINARY, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenWithScanArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Scan != nil {
		if err := oprot.WriteFieldBegin("scan", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:scan: %s", p, err)
		}
		if err := p.Scan.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Scan)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:scan: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenWithScanArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Attributes != nil {
		if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:attributes: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.BINARY, thrift.BINARY, len(p.Attributes)); err != nil {
			return fmt.Errorf("error writing map begin: %s")
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteBinary(k); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:attributes: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenWithScanArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerOpenWithScanArgs(%+v)", *p)
}

type ScannerOpenWithScanResult struct {
	Success ScannerID `thrift:"success,0"`
	Io      *IOError  `thrift:"io,1"`
}

func NewScannerOpenWithScanResult() *ScannerOpenWithScanResult {
	return &ScannerOpenWithScanResult{}
}

func (p *ScannerOpenWithScanResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerOpenWithScanResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = ScannerID(v)
	}
	return nil
}

func (p *ScannerOpenWithScanResult) readField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io)
	}
	return nil
}

func (p *ScannerOpenWithScanResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scannerOpenWithScan_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerOpenWithScanResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.I32, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *ScannerOpenWithScanResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenWithScanResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerOpenWithScanResult(%+v)", *p)
}

type ScannerOpenArgs struct {
	TableName  Text          `thrift:"tableName,1"`
	StartRow   Text          `thrift:"startRow,2"`
	Columns    []Text        `thrift:"columns,3"`
	Attributes map[Text]Text `thrift:"attributes,4"`
}

func NewScannerOpenArgs() *ScannerOpenArgs {
	return &ScannerOpenArgs{}
}

func (p *ScannerOpenArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerOpenArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.TableName = Text(v)
	}
	return nil
}

func (p *ScannerOpenArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.StartRow = Text(v)
	}
	return nil
}

func (p *ScannerOpenArgs) readField3(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Columns = make([]Text, 0, size)
	for i := 0; i < size; i++ {
		var _elem281 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_elem281 = Text(v)
		}
		p.Columns = append(p.Columns, _elem281)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *ScannerOpenArgs) readField4(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s")
	}
	p.Attributes = make(map[Text]Text, size)
	for i := 0; i < size; i++ {
		var _key282 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_key282 = Text(v)
		}
		var _val283 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_val283 = Text(v)
		}
		p.Attributes[_key282] = _val283
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s")
	}
	return nil
}

func (p *ScannerOpenArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scannerOpen_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerOpenArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.BINARY, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.StartRow != nil {
		if err := oprot.WriteFieldBegin("startRow", thrift.BINARY, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:startRow: %s", p, err)
		}
		if err := oprot.WriteBinary(p.StartRow); err != nil {
			return fmt.Errorf("%T.startRow (2) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:startRow: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Columns != nil {
		if err := oprot.WriteFieldBegin("columns", thrift.LIST, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:columns: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.BINARY, len(p.Columns)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Columns {
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:columns: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if p.Attributes != nil {
		if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:attributes: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.BINARY, thrift.BINARY, len(p.Attributes)); err != nil {
			return fmt.Errorf("error writing map begin: %s")
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteBinary(k); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:attributes: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerOpenArgs(%+v)", *p)
}

type ScannerOpenResult struct {
	Success ScannerID `thrift:"success,0"`
	Io      *IOError  `thrift:"io,1"`
}

func NewScannerOpenResult() *ScannerOpenResult {
	return &ScannerOpenResult{}
}

func (p *ScannerOpenResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerOpenResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = ScannerID(v)
	}
	return nil
}

func (p *ScannerOpenResult) readField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io)
	}
	return nil
}

func (p *ScannerOpenResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scannerOpen_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerOpenResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.I32, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *ScannerOpenResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerOpenResult(%+v)", *p)
}

type ScannerOpenWithStopArgs struct {
	TableName  Text          `thrift:"tableName,1"`
	StartRow   Text          `thrift:"startRow,2"`
	StopRow    Text          `thrift:"stopRow,3"`
	Columns    []Text        `thrift:"columns,4"`
	Attributes map[Text]Text `thrift:"attributes,5"`
}

func NewScannerOpenWithStopArgs() *ScannerOpenWithStopArgs {
	return &ScannerOpenWithStopArgs{}
}

func (p *ScannerOpenWithStopArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.readField5(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerOpenWithStopArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.TableName = Text(v)
	}
	return nil
}

func (p *ScannerOpenWithStopArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.StartRow = Text(v)
	}
	return nil
}

func (p *ScannerOpenWithStopArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.StopRow = Text(v)
	}
	return nil
}

func (p *ScannerOpenWithStopArgs) readField4(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Columns = make([]Text, 0, size)
	for i := 0; i < size; i++ {
		var _elem284 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_elem284 = Text(v)
		}
		p.Columns = append(p.Columns, _elem284)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *ScannerOpenWithStopArgs) readField5(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s")
	}
	p.Attributes = make(map[Text]Text, size)
	for i := 0; i < size; i++ {
		var _key285 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_key285 = Text(v)
		}
		var _val286 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_val286 = Text(v)
		}
		p.Attributes[_key285] = _val286
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s")
	}
	return nil
}

func (p *ScannerOpenWithStopArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scannerOpenWithStop_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerOpenWithStopArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.BINARY, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenWithStopArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.StartRow != nil {
		if err := oprot.WriteFieldBegin("startRow", thrift.BINARY, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:startRow: %s", p, err)
		}
		if err := oprot.WriteBinary(p.StartRow); err != nil {
			return fmt.Errorf("%T.startRow (2) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:startRow: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenWithStopArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.StopRow != nil {
		if err := oprot.WriteFieldBegin("stopRow", thrift.BINARY, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:stopRow: %s", p, err)
		}
		if err := oprot.WriteBinary(p.StopRow); err != nil {
			return fmt.Errorf("%T.stopRow (3) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:stopRow: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenWithStopArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if p.Columns != nil {
		if err := oprot.WriteFieldBegin("columns", thrift.LIST, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:columns: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.BINARY, len(p.Columns)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Columns {
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:columns: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenWithStopArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if p.Attributes != nil {
		if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 5); err != nil {
			return fmt.Errorf("%T write field begin error 5:attributes: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.BINARY, thrift.BINARY, len(p.Attributes)); err != nil {
			return fmt.Errorf("error writing map begin: %s")
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteBinary(k); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 5:attributes: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenWithStopArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerOpenWithStopArgs(%+v)", *p)
}

type ScannerOpenWithStopResult struct {
	Success ScannerID `thrift:"success,0"`
	Io      *IOError  `thrift:"io,1"`
}

func NewScannerOpenWithStopResult() *ScannerOpenWithStopResult {
	return &ScannerOpenWithStopResult{}
}

func (p *ScannerOpenWithStopResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerOpenWithStopResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = ScannerID(v)
	}
	return nil
}

func (p *ScannerOpenWithStopResult) readField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io)
	}
	return nil
}

func (p *ScannerOpenWithStopResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scannerOpenWithStop_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerOpenWithStopResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.I32, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *ScannerOpenWithStopResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenWithStopResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerOpenWithStopResult(%+v)", *p)
}

type ScannerOpenWithPrefixArgs struct {
	TableName      Text          `thrift:"tableName,1"`
	StartAndPrefix Text          `thrift:"startAndPrefix,2"`
	Columns        []Text        `thrift:"columns,3"`
	Attributes     map[Text]Text `thrift:"attributes,4"`
}

func NewScannerOpenWithPrefixArgs() *ScannerOpenWithPrefixArgs {
	return &ScannerOpenWithPrefixArgs{}
}

func (p *ScannerOpenWithPrefixArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerOpenWithPrefixArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.TableName = Text(v)
	}
	return nil
}

func (p *ScannerOpenWithPrefixArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.StartAndPrefix = Text(v)
	}
	return nil
}

func (p *ScannerOpenWithPrefixArgs) readField3(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Columns = make([]Text, 0, size)
	for i := 0; i < size; i++ {
		var _elem287 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_elem287 = Text(v)
		}
		p.Columns = append(p.Columns, _elem287)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *ScannerOpenWithPrefixArgs) readField4(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s")
	}
	p.Attributes = make(map[Text]Text, size)
	for i := 0; i < size; i++ {
		var _key288 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_key288 = Text(v)
		}
		var _val289 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_val289 = Text(v)
		}
		p.Attributes[_key288] = _val289
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s")
	}
	return nil
}

func (p *ScannerOpenWithPrefixArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scannerOpenWithPrefix_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerOpenWithPrefixArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.BINARY, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenWithPrefixArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.StartAndPrefix != nil {
		if err := oprot.WriteFieldBegin("startAndPrefix", thrift.BINARY, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:startAndPrefix: %s", p, err)
		}
		if err := oprot.WriteBinary(p.StartAndPrefix); err != nil {
			return fmt.Errorf("%T.startAndPrefix (2) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:startAndPrefix: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenWithPrefixArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Columns != nil {
		if err := oprot.WriteFieldBegin("columns", thrift.LIST, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:columns: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.BINARY, len(p.Columns)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Columns {
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:columns: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenWithPrefixArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if p.Attributes != nil {
		if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:attributes: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.BINARY, thrift.BINARY, len(p.Attributes)); err != nil {
			return fmt.Errorf("error writing map begin: %s")
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteBinary(k); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:attributes: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenWithPrefixArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerOpenWithPrefixArgs(%+v)", *p)
}

type ScannerOpenWithPrefixResult struct {
	Success ScannerID `thrift:"success,0"`
	Io      *IOError  `thrift:"io,1"`
}

func NewScannerOpenWithPrefixResult() *ScannerOpenWithPrefixResult {
	return &ScannerOpenWithPrefixResult{}
}

func (p *ScannerOpenWithPrefixResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerOpenWithPrefixResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = ScannerID(v)
	}
	return nil
}

func (p *ScannerOpenWithPrefixResult) readField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io)
	}
	return nil
}

func (p *ScannerOpenWithPrefixResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scannerOpenWithPrefix_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerOpenWithPrefixResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.I32, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *ScannerOpenWithPrefixResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenWithPrefixResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerOpenWithPrefixResult(%+v)", *p)
}

type ScannerOpenTsArgs struct {
	TableName  Text          `thrift:"tableName,1"`
	StartRow   Text          `thrift:"startRow,2"`
	Columns    []Text        `thrift:"columns,3"`
	Timestamp  int64         `thrift:"timestamp,4"`
	Attributes map[Text]Text `thrift:"attributes,5"`
}

func NewScannerOpenTsArgs() *ScannerOpenTsArgs {
	return &ScannerOpenTsArgs{}
}

func (p *ScannerOpenTsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.readField5(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerOpenTsArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.TableName = Text(v)
	}
	return nil
}

func (p *ScannerOpenTsArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.StartRow = Text(v)
	}
	return nil
}

func (p *ScannerOpenTsArgs) readField3(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Columns = make([]Text, 0, size)
	for i := 0; i < size; i++ {
		var _elem290 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_elem290 = Text(v)
		}
		p.Columns = append(p.Columns, _elem290)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *ScannerOpenTsArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 4: %s")
	} else {
		p.Timestamp = v
	}
	return nil
}

func (p *ScannerOpenTsArgs) readField5(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s")
	}
	p.Attributes = make(map[Text]Text, size)
	for i := 0; i < size; i++ {
		var _key291 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_key291 = Text(v)
		}
		var _val292 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_val292 = Text(v)
		}
		p.Attributes[_key291] = _val292
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s")
	}
	return nil
}

func (p *ScannerOpenTsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scannerOpenTs_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerOpenTsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.BINARY, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenTsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.StartRow != nil {
		if err := oprot.WriteFieldBegin("startRow", thrift.BINARY, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:startRow: %s", p, err)
		}
		if err := oprot.WriteBinary(p.StartRow); err != nil {
			return fmt.Errorf("%T.startRow (2) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:startRow: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenTsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Columns != nil {
		if err := oprot.WriteFieldBegin("columns", thrift.LIST, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:columns: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.BINARY, len(p.Columns)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Columns {
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:columns: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenTsArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("timestamp", thrift.I64, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:timestamp: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Timestamp)); err != nil {
		return fmt.Errorf("%T.timestamp (4) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:timestamp: %s", p, err)
	}
	return err
}

func (p *ScannerOpenTsArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if p.Attributes != nil {
		if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 5); err != nil {
			return fmt.Errorf("%T write field begin error 5:attributes: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.BINARY, thrift.BINARY, len(p.Attributes)); err != nil {
			return fmt.Errorf("error writing map begin: %s")
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteBinary(k); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 5:attributes: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenTsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerOpenTsArgs(%+v)", *p)
}

type ScannerOpenTsResult struct {
	Success ScannerID `thrift:"success,0"`
	Io      *IOError  `thrift:"io,1"`
}

func NewScannerOpenTsResult() *ScannerOpenTsResult {
	return &ScannerOpenTsResult{}
}

func (p *ScannerOpenTsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerOpenTsResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = ScannerID(v)
	}
	return nil
}

func (p *ScannerOpenTsResult) readField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io)
	}
	return nil
}

func (p *ScannerOpenTsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scannerOpenTs_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerOpenTsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.I32, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *ScannerOpenTsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenTsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerOpenTsResult(%+v)", *p)
}

type ScannerOpenWithStopTsArgs struct {
	TableName  Text          `thrift:"tableName,1"`
	StartRow   Text          `thrift:"startRow,2"`
	StopRow    Text          `thrift:"stopRow,3"`
	Columns    []Text        `thrift:"columns,4"`
	Timestamp  int64         `thrift:"timestamp,5"`
	Attributes map[Text]Text `thrift:"attributes,6"`
}

func NewScannerOpenWithStopTsArgs() *ScannerOpenWithStopTsArgs {
	return &ScannerOpenWithStopTsArgs{}
}

func (p *ScannerOpenWithStopTsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.readField5(iprot); err != nil {
				return err
			}
		case 6:
			if err := p.readField6(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerOpenWithStopTsArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.TableName = Text(v)
	}
	return nil
}

func (p *ScannerOpenWithStopTsArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.StartRow = Text(v)
	}
	return nil
}

func (p *ScannerOpenWithStopTsArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.StopRow = Text(v)
	}
	return nil
}

func (p *ScannerOpenWithStopTsArgs) readField4(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Columns = make([]Text, 0, size)
	for i := 0; i < size; i++ {
		var _elem293 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_elem293 = Text(v)
		}
		p.Columns = append(p.Columns, _elem293)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *ScannerOpenWithStopTsArgs) readField5(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 5: %s")
	} else {
		p.Timestamp = v
	}
	return nil
}

func (p *ScannerOpenWithStopTsArgs) readField6(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s")
	}
	p.Attributes = make(map[Text]Text, size)
	for i := 0; i < size; i++ {
		var _key294 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_key294 = Text(v)
		}
		var _val295 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_val295 = Text(v)
		}
		p.Attributes[_key294] = _val295
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s")
	}
	return nil
}

func (p *ScannerOpenWithStopTsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scannerOpenWithStopTs_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := p.writeField6(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerOpenWithStopTsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.BINARY, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenWithStopTsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.StartRow != nil {
		if err := oprot.WriteFieldBegin("startRow", thrift.BINARY, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:startRow: %s", p, err)
		}
		if err := oprot.WriteBinary(p.StartRow); err != nil {
			return fmt.Errorf("%T.startRow (2) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:startRow: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenWithStopTsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.StopRow != nil {
		if err := oprot.WriteFieldBegin("stopRow", thrift.BINARY, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:stopRow: %s", p, err)
		}
		if err := oprot.WriteBinary(p.StopRow); err != nil {
			return fmt.Errorf("%T.stopRow (3) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:stopRow: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenWithStopTsArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if p.Columns != nil {
		if err := oprot.WriteFieldBegin("columns", thrift.LIST, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:columns: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.BINARY, len(p.Columns)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Columns {
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:columns: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenWithStopTsArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("timestamp", thrift.I64, 5); err != nil {
		return fmt.Errorf("%T write field begin error 5:timestamp: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Timestamp)); err != nil {
		return fmt.Errorf("%T.timestamp (5) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 5:timestamp: %s", p, err)
	}
	return err
}

func (p *ScannerOpenWithStopTsArgs) writeField6(oprot thrift.TProtocol) (err error) {
	if p.Attributes != nil {
		if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 6); err != nil {
			return fmt.Errorf("%T write field begin error 6:attributes: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.BINARY, thrift.BINARY, len(p.Attributes)); err != nil {
			return fmt.Errorf("error writing map begin: %s")
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteBinary(k); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 6:attributes: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenWithStopTsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerOpenWithStopTsArgs(%+v)", *p)
}

type ScannerOpenWithStopTsResult struct {
	Success ScannerID `thrift:"success,0"`
	Io      *IOError  `thrift:"io,1"`
}

func NewScannerOpenWithStopTsResult() *ScannerOpenWithStopTsResult {
	return &ScannerOpenWithStopTsResult{}
}

func (p *ScannerOpenWithStopTsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerOpenWithStopTsResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = ScannerID(v)
	}
	return nil
}

func (p *ScannerOpenWithStopTsResult) readField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io)
	}
	return nil
}

func (p *ScannerOpenWithStopTsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scannerOpenWithStopTs_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerOpenWithStopTsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.I32, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *ScannerOpenWithStopTsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenWithStopTsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerOpenWithStopTsResult(%+v)", *p)
}

type ScannerGetArgs struct {
	Id ScannerID `thrift:"id,1"`
}

func NewScannerGetArgs() *ScannerGetArgs {
	return &ScannerGetArgs{}
}

func (p *ScannerGetArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerGetArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Id = ScannerID(v)
	}
	return nil
}

func (p *ScannerGetArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scannerGet_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerGetArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("id", thrift.I32, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:id: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Id)); err != nil {
		return fmt.Errorf("%T.id (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:id: %s", p, err)
	}
	return err
}

func (p *ScannerGetArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerGetArgs(%+v)", *p)
}

type ScannerGetResult struct {
	Success []*TRowResult    `thrift:"success,0"`
	Io      *IOError         `thrift:"io,1"`
	Ia      *IllegalArgument `thrift:"ia,2"`
}

func NewScannerGetResult() *ScannerGetResult {
	return &ScannerGetResult{}
}

func (p *ScannerGetResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerGetResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]*TRowResult, 0, size)
	for i := 0; i < size; i++ {
		_elem296 := NewTRowResult()
		if err := _elem296.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem296)
		}
		p.Success = append(p.Success, _elem296)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *ScannerGetResult) readField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io)
	}
	return nil
}

func (p *ScannerGetResult) readField2(iprot thrift.TProtocol) error {
	p.Ia = NewIllegalArgument()
	if err := p.Ia.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ia)
	}
	return nil
}

func (p *ScannerGetResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scannerGet_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Ia != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerGetResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *ScannerGetResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *ScannerGetResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ia != nil {
		if err := oprot.WriteFieldBegin("ia", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ia: %s", p, err)
		}
		if err := p.Ia.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ia)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ia: %s", p, err)
		}
	}
	return err
}

func (p *ScannerGetResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerGetResult(%+v)", *p)
}

type ScannerGetListArgs struct {
	Id     ScannerID `thrift:"id,1"`
	NbRows int32     `thrift:"nbRows,2"`
}

func NewScannerGetListArgs() *ScannerGetListArgs {
	return &ScannerGetListArgs{}
}

func (p *ScannerGetListArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerGetListArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Id = ScannerID(v)
	}
	return nil
}

func (p *ScannerGetListArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.NbRows = v
	}
	return nil
}

func (p *ScannerGetListArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scannerGetList_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerGetListArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("id", thrift.I32, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:id: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Id)); err != nil {
		return fmt.Errorf("%T.id (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:id: %s", p, err)
	}
	return err
}

func (p *ScannerGetListArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("nbRows", thrift.I32, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:nbRows: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.NbRows)); err != nil {
		return fmt.Errorf("%T.nbRows (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:nbRows: %s", p, err)
	}
	return err
}

func (p *ScannerGetListArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerGetListArgs(%+v)", *p)
}

type ScannerGetListResult struct {
	Success []*TRowResult    `thrift:"success,0"`
	Io      *IOError         `thrift:"io,1"`
	Ia      *IllegalArgument `thrift:"ia,2"`
}

func NewScannerGetListResult() *ScannerGetListResult {
	return &ScannerGetListResult{}
}

func (p *ScannerGetListResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerGetListResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]*TRowResult, 0, size)
	for i := 0; i < size; i++ {
		_elem297 := NewTRowResult()
		if err := _elem297.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem297)
		}
		p.Success = append(p.Success, _elem297)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *ScannerGetListResult) readField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io)
	}
	return nil
}

func (p *ScannerGetListResult) readField2(iprot thrift.TProtocol) error {
	p.Ia = NewIllegalArgument()
	if err := p.Ia.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ia)
	}
	return nil
}

func (p *ScannerGetListResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scannerGetList_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Ia != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerGetListResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *ScannerGetListResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *ScannerGetListResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ia != nil {
		if err := oprot.WriteFieldBegin("ia", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ia: %s", p, err)
		}
		if err := p.Ia.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ia)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ia: %s", p, err)
		}
	}
	return err
}

func (p *ScannerGetListResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerGetListResult(%+v)", *p)
}

type ScannerCloseArgs struct {
	Id ScannerID `thrift:"id,1"`
}

func NewScannerCloseArgs() *ScannerCloseArgs {
	return &ScannerCloseArgs{}
}

func (p *ScannerCloseArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerCloseArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Id = ScannerID(v)
	}
	return nil
}

func (p *ScannerCloseArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scannerClose_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerCloseArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("id", thrift.I32, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:id: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Id)); err != nil {
		return fmt.Errorf("%T.id (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:id: %s", p, err)
	}
	return err
}

func (p *ScannerCloseArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerCloseArgs(%+v)", *p)
}

type ScannerCloseResult struct {
	Io *IOError         `thrift:"io,1"`
	Ia *IllegalArgument `thrift:"ia,2"`
}

func NewScannerCloseResult() *ScannerCloseResult {
	return &ScannerCloseResult{}
}

func (p *ScannerCloseResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerCloseResult) readField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io)
	}
	return nil
}

func (p *ScannerCloseResult) readField2(iprot thrift.TProtocol) error {
	p.Ia = NewIllegalArgument()
	if err := p.Ia.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ia)
	}
	return nil
}

func (p *ScannerCloseResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scannerClose_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Ia != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerCloseResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *ScannerCloseResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ia != nil {
		if err := oprot.WriteFieldBegin("ia", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ia: %s", p, err)
		}
		if err := p.Ia.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ia)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ia: %s", p, err)
		}
	}
	return err
}

func (p *ScannerCloseResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerCloseResult(%+v)", *p)
}

type GetRowOrBeforeArgs struct {
	TableName Text `thrift:"tableName,1"`
	Row       Text `thrift:"row,2"`
	Family    Text `thrift:"family,3"`
}

func NewGetRowOrBeforeArgs() *GetRowOrBeforeArgs {
	return &GetRowOrBeforeArgs{}
}

func (p *GetRowOrBeforeArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowOrBeforeArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.TableName = Text(v)
	}
	return nil
}

func (p *GetRowOrBeforeArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Row = Text(v)
	}
	return nil
}

func (p *GetRowOrBeforeArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.Family = Text(v)
	}
	return nil
}

func (p *GetRowOrBeforeArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRowOrBefore_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowOrBeforeArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.BINARY, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *GetRowOrBeforeArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Row != nil {
		if err := oprot.WriteFieldBegin("row", thrift.BINARY, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Row); err != nil {
			return fmt.Errorf("%T.row (2) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:row: %s", p, err)
		}
	}
	return err
}

func (p *GetRowOrBeforeArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Family != nil {
		if err := oprot.WriteFieldBegin("family", thrift.BINARY, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:family: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Family); err != nil {
			return fmt.Errorf("%T.family (3) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:family: %s", p, err)
		}
	}
	return err
}

func (p *GetRowOrBeforeArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowOrBeforeArgs(%+v)", *p)
}

type GetRowOrBeforeResult struct {
	Success []*TCell `thrift:"success,0"`
	Io      *IOError `thrift:"io,1"`
}

func NewGetRowOrBeforeResult() *GetRowOrBeforeResult {
	return &GetRowOrBeforeResult{}
}

func (p *GetRowOrBeforeResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowOrBeforeResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]*TCell, 0, size)
	for i := 0; i < size; i++ {
		_elem298 := NewTCell()
		if err := _elem298.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem298)
		}
		p.Success = append(p.Success, _elem298)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *GetRowOrBeforeResult) readField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io)
	}
	return nil
}

func (p *GetRowOrBeforeResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRowOrBefore_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowOrBeforeResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetRowOrBeforeResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetRowOrBeforeResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowOrBeforeResult(%+v)", *p)
}

type GetRegionInfoArgs struct {
	Row Text `thrift:"row,1"`
}

func NewGetRegionInfoArgs() *GetRegionInfoArgs {
	return &GetRegionInfoArgs{}
}

func (p *GetRegionInfoArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRegionInfoArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Row = Text(v)
	}
	return nil
}

func (p *GetRegionInfoArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRegionInfo_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRegionInfoArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Row != nil {
		if err := oprot.WriteFieldBegin("row", thrift.BINARY, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:row: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Row); err != nil {
			return fmt.Errorf("%T.row (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:row: %s", p, err)
		}
	}
	return err
}

func (p *GetRegionInfoArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRegionInfoArgs(%+v)", *p)
}

type GetRegionInfoResult struct {
	Success *TRegionInfo `thrift:"success,0"`
	Io      *IOError     `thrift:"io,1"`
}

func NewGetRegionInfoResult() *GetRegionInfoResult {
	return &GetRegionInfoResult{}
}

func (p *GetRegionInfoResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRegionInfoResult) readField0(iprot thrift.TProtocol) error {
	p.Success = NewTRegionInfo()
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *GetRegionInfoResult) readField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io)
	}
	return nil
}

func (p *GetRegionInfoResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRegionInfo_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRegionInfoResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetRegionInfoResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetRegionInfoResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRegionInfoResult(%+v)", *p)
}

type GetRowWithColumnsMaxVerArgs struct {
	TableName   Text          `thrift:"tableName,1"`
	Row         Text          `thrift:"row,2"`
	Columns     []Text        `thrift:"columns,3"`
	NumVersions int32         `thrift:"numVersions,4"`
	Attributes  map[Text]Text `thrift:"attributes,5"`
}

func NewGetRowWithColumnsMaxVerArgs() *GetRowWithColumnsMaxVerArgs {
	return &GetRowWithColumnsMaxVerArgs{}
}

func (p *GetRowWithColumnsMaxVerArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.readField5(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowWithColumnsMaxVerArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.TableName = Text(v)
	}
	return nil
}

func (p *GetRowWithColumnsMaxVerArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Row = Text(v)
	}
	return nil
}

func (p *GetRowWithColumnsMaxVerArgs) readField3(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Columns = make([]Text, 0, size)
	for i := 0; i < size; i++ {
		var _elem299 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_elem299 = Text(v)
		}
		p.Columns = append(p.Columns, _elem299)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *GetRowWithColumnsMaxVerArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 4: %s")
	} else {
		p.NumVersions = v
	}
	return nil
}

func (p *GetRowWithColumnsMaxVerArgs) readField5(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s")
	}
	p.Attributes = make(map[Text]Text, size)
	for i := 0; i < size; i++ {
		var _key300 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_key300 = Text(v)
		}
		var _val301 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_val301 = Text(v)
		}
		p.Attributes[_key300] = _val301
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s")
	}
	return nil
}

func (p *GetRowWithColumnsMaxVerArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRowWithColumnsMaxVer_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowWithColumnsMaxVerArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.BINARY, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *GetRowWithColumnsMaxVerArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Row != nil {
		if err := oprot.WriteFieldBegin("row", thrift.BINARY, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Row); err != nil {
			return fmt.Errorf("%T.row (2) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:row: %s", p, err)
		}
	}
	return err
}

func (p *GetRowWithColumnsMaxVerArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Columns != nil {
		if err := oprot.WriteFieldBegin("columns", thrift.LIST, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:columns: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.BINARY, len(p.Columns)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Columns {
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:columns: %s", p, err)
		}
	}
	return err
}

func (p *GetRowWithColumnsMaxVerArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("numVersions", thrift.I32, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:numVersions: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.NumVersions)); err != nil {
		return fmt.Errorf("%T.numVersions (4) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:numVersions: %s", p, err)
	}
	return err
}

func (p *GetRowWithColumnsMaxVerArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if p.Attributes != nil {
		if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 5); err != nil {
			return fmt.Errorf("%T write field begin error 5:attributes: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.BINARY, thrift.BINARY, len(p.Attributes)); err != nil {
			return fmt.Errorf("error writing map begin: %s")
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteBinary(k); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 5:attributes: %s", p, err)
		}
	}
	return err
}

func (p *GetRowWithColumnsMaxVerArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowWithColumnsMaxVerArgs(%+v)", *p)
}

type GetRowWithColumnsMaxVerResult struct {
	Success []*TRowResultWithMultiColVer `thrift:"success,0"`
	Io      *IOError                     `thrift:"io,1"`
}

func NewGetRowWithColumnsMaxVerResult() *GetRowWithColumnsMaxVerResult {
	return &GetRowWithColumnsMaxVerResult{}
}

func (p *GetRowWithColumnsMaxVerResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowWithColumnsMaxVerResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]*TRowResultWithMultiColVer, 0, size)
	for i := 0; i < size; i++ {
		_elem302 := NewTRowResultWithMultiColVer()
		if err := _elem302.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem302)
		}
		p.Success = append(p.Success, _elem302)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *GetRowWithColumnsMaxVerResult) readField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io)
	}
	return nil
}

func (p *GetRowWithColumnsMaxVerResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRowWithColumnsMaxVer_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowWithColumnsMaxVerResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetRowWithColumnsMaxVerResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetRowWithColumnsMaxVerResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowWithColumnsMaxVerResult(%+v)", *p)
}

type GetRowWithColumnsTsMaxVerArgs struct {
	TableName   Text          `thrift:"tableName,1"`
	Row         Text          `thrift:"row,2"`
	Columns     []Text        `thrift:"columns,3"`
	Timestamp   int64         `thrift:"timestamp,4"`
	NumVersions int32         `thrift:"numVersions,5"`
	Attributes  map[Text]Text `thrift:"attributes,6"`
}

func NewGetRowWithColumnsTsMaxVerArgs() *GetRowWithColumnsTsMaxVerArgs {
	return &GetRowWithColumnsTsMaxVerArgs{}
}

func (p *GetRowWithColumnsTsMaxVerArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.readField5(iprot); err != nil {
				return err
			}
		case 6:
			if err := p.readField6(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowWithColumnsTsMaxVerArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.TableName = Text(v)
	}
	return nil
}

func (p *GetRowWithColumnsTsMaxVerArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Row = Text(v)
	}
	return nil
}

func (p *GetRowWithColumnsTsMaxVerArgs) readField3(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Columns = make([]Text, 0, size)
	for i := 0; i < size; i++ {
		var _elem303 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_elem303 = Text(v)
		}
		p.Columns = append(p.Columns, _elem303)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *GetRowWithColumnsTsMaxVerArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 4: %s")
	} else {
		p.Timestamp = v
	}
	return nil
}

func (p *GetRowWithColumnsTsMaxVerArgs) readField5(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 5: %s")
	} else {
		p.NumVersions = v
	}
	return nil
}

func (p *GetRowWithColumnsTsMaxVerArgs) readField6(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s")
	}
	p.Attributes = make(map[Text]Text, size)
	for i := 0; i < size; i++ {
		var _key304 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_key304 = Text(v)
		}
		var _val305 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_val305 = Text(v)
		}
		p.Attributes[_key304] = _val305
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s")
	}
	return nil
}

func (p *GetRowWithColumnsTsMaxVerArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRowWithColumnsTsMaxVer_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := p.writeField6(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowWithColumnsTsMaxVerArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.TableName != nil {
		if err := oprot.WriteFieldBegin("tableName", thrift.BINARY, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
		}
		if err := oprot.WriteBinary(p.TableName); err != nil {
			return fmt.Errorf("%T.tableName (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
		}
	}
	return err
}

func (p *GetRowWithColumnsTsMaxVerArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Row != nil {
		if err := oprot.WriteFieldBegin("row", thrift.BINARY, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Row); err != nil {
			return fmt.Errorf("%T.row (2) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:row: %s", p, err)
		}
	}
	return err
}

func (p *GetRowWithColumnsTsMaxVerArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Columns != nil {
		if err := oprot.WriteFieldBegin("columns", thrift.LIST, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:columns: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.BINARY, len(p.Columns)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Columns {
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:columns: %s", p, err)
		}
	}
	return err
}

func (p *GetRowWithColumnsTsMaxVerArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("timestamp", thrift.I64, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:timestamp: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Timestamp)); err != nil {
		return fmt.Errorf("%T.timestamp (4) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:timestamp: %s", p, err)
	}
	return err
}

func (p *GetRowWithColumnsTsMaxVerArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("numVersions", thrift.I32, 5); err != nil {
		return fmt.Errorf("%T write field begin error 5:numVersions: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.NumVersions)); err != nil {
		return fmt.Errorf("%T.numVersions (5) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 5:numVersions: %s", p, err)
	}
	return err
}

func (p *GetRowWithColumnsTsMaxVerArgs) writeField6(oprot thrift.TProtocol) (err error) {
	if p.Attributes != nil {
		if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 6); err != nil {
			return fmt.Errorf("%T write field begin error 6:attributes: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.BINARY, thrift.BINARY, len(p.Attributes)); err != nil {
			return fmt.Errorf("error writing map begin: %s")
		}
		for k, v := range p.Attributes {
			if err := oprot.WriteBinary(k); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 6:attributes: %s", p, err)
		}
	}
	return err
}

func (p *GetRowWithColumnsTsMaxVerArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowWithColumnsTsMaxVerArgs(%+v)", *p)
}

type GetRowWithColumnsTsMaxVerResult struct {
	Success []*TRowResultWithMultiColVer `thrift:"success,0"`
	Io      *IOError                     `thrift:"io,1"`
}

func NewGetRowWithColumnsTsMaxVerResult() *GetRowWithColumnsTsMaxVerResult {
	return &GetRowWithColumnsTsMaxVerResult{}
}

func (p *GetRowWithColumnsTsMaxVerResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowWithColumnsTsMaxVerResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]*TRowResultWithMultiColVer, 0, size)
	for i := 0; i < size; i++ {
		_elem306 := NewTRowResultWithMultiColVer()
		if err := _elem306.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem306)
		}
		p.Success = append(p.Success, _elem306)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *GetRowWithColumnsTsMaxVerResult) readField1(iprot thrift.TProtocol) error {
	p.Io = NewIOError()
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io)
	}
	return nil
}

func (p *GetRowWithColumnsTsMaxVerResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRowWithColumnsTsMaxVer_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Io != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowWithColumnsTsMaxVerResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetRowWithColumnsTsMaxVerResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Io != nil {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetRowWithColumnsTsMaxVerResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowWithColumnsTsMaxVerResult(%+v)", *p)
}
